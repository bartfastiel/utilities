<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!-- Generated by Apache Maven Doxia Site Renderer 1.7.4 at 2017 -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>universAAL Utilities Suite &#x2013; CPD Results</title>
    <style type="text/css" media="all">
      @import url("./css/maven-base.css");
      @import url("./css/maven-theme.css");
      @import url("./css/site.css");
    </style>
    <link rel="stylesheet" href="./css/print.css" type="text/css" media="print" />
    <meta http-equiv="Content-Language" content="en" />
        
        </head>
  <body class="composite">
    <div id="banner">
                    <div id="bannerLeft">
                universAAL Utilities Suite
                </div>
                    <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="breadcrumbs">
          
                <div class="xleft">
        <span id="publishDate">Last Published: 2017</span>
                  &nbsp;| <span id="projectVersion">Version: 3.4.2-SNAPSHOT</span>
                      </div>
            <div class="xright">                    <a href="./" title="universAAL Utilities Suite">universAAL Utilities Suite</a>
            
      </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
    <div id="leftColumn">
      <div id="navcolumn">
           
                                <h5>Parent Project</h5>
                  <ul>
                  <li class="none">
                          <a href="../../../platform/index.html" title="universAAL Super POM">universAAL Super POM</a>
            </li>
          </ul>
                       <h5>Modules</h5>
                  <ul>
                  <li class="none">
                          <a href="../uAAL.utils/index.html" title="universAAL Support Utilities API">universAAL Support Utilities API</a>
            </li>
                  <li class="none">
                          <a href="../utilities.api/index.html" title="universAAL Utilities APIs">universAAL Utilities APIs</a>
            </li>
                  <li class="none">
                          <a href="../utilities.ioc/index.html" title="universAAL Inversion of Control for Dependencies">universAAL Inversion of Control for Dependencies</a>
            </li>
                  <li class="none">
                          <a href="utilities.karaf.feature/index.html" title="universAAL Utils Karaf Feature">universAAL Utils Karaf Feature</a>
            </li>
          </ul>
                       <h5>Project Documentation</h5>
                  <ul>
                                                                                      <li class="collapsed">
                          <a href="project-info.html" title="Project Information">Project Information</a>
                  </li>
                                                                                                                                                                                          <li class="expanded">
                          <a href="project-reports.html" title="Project Reports">Project Reports</a>
                    <ul>
                      <li class="none">
                          <a href="checkstyle-aggregate.html" title="Checkstyle">Checkstyle</a>
            </li>
                      <li class="none">
            <strong>CPD</strong>
          </li>
                      <li class="none">
                          <a href="pmd.html" title="PMD">PMD</a>
            </li>
                      <li class="none">
                          <a href="cobertura/index.html" title="Cobertura Test Coverage">Cobertura Test Coverage</a>
            </li>
                      <li class="none">
                          <a href="apidocs/index.html" title="JavaDocs">JavaDocs</a>
            </li>
                      <li class="none">
                          <a href="taglist.html" title="Tag List">Tag List</a>
            </li>
                      <li class="none">
                          <a href="directive-checks.html" title="universAAL Directive Checks">universAAL Directive Checks</a>
            </li>
              </ul>
        </li>
          </ul>
                             <a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy">
        <img class="poweredBy" alt="Built by Maven" src="./images/logos/maven-feather.png" />
      </a>
                 
            </div>
    </div>
    <div id="bodyColumn">
      <div id="contentBox">
        <div class="section">
<h2><a name="CPD_Results"></a>CPD Results</h2>
<p>The following document contains the results of PMD's  <a class="externalLink" href="http://pmd.sourceforge.net/cpd.html">CPD</a> 5.6.1.</p></div>
<div class="section">
<h2><a name="Duplications"></a>Duplications</h2>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/service/low/Profile.java</td>
<td>universAAL Support Utilities API</td>
<td>70</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/service/low/Profile.java</td>
<td>universAAL Utilities APIs</td>
<td>70</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class Profile {

	/**
	 * Default namespace.
	 */
	public static final String MY_NAMESPACE = &quot;http://org.universAAL.ontology/SimpleUtils.owl#&quot;;
	/**
	 * Allocate a service.
	 */
	public Service service;

	/**
	 * Use this helper class to create a ServiceProfile that is easy to use.
	 * This Profile does not extend ServiceProfile. you will have to get it with
	 * getTheProfile();.
	 * &lt;p/&gt;
	 * Example: &lt;code&gt;
	 * Profile prof=new Profile(new ProvidedLightingService(REF_URI_NEW_SERVICE));&lt;/code&gt;
	 *
	 * @param profiledServiceRoot
	 *            An instance of the ProvidedService class that you are using to
	 *            register the profiles, with an appropriate reference URI.
	 */
	public Profile(Service profiledServiceRoot) {
		this.service = profiledServiceRoot;
	}

	/**
	 * Use this helper method to declare an argument over a Profile, specifying
	 * that the created profile must have, in the given branch of properties, an
	 * instance of the &lt;b&gt;same type&lt;/b&gt; expressed with Typematch argument.
	 * &lt;p/&gt;
	 * Example: &lt;code&gt;
	 * req.put(new String[]{Lighting.PROP_CONTROLS,LightSource.PROP_HAS_TYPE}, new Typematch(ElectricLight.MY_URI));
	 * &lt;/code&gt;
	 *
	 * @param branch
	 *            The path of properties from the Service root class to the
	 *            value to be restricted
	 * @param leaf
	 *            The Typematch describing the type of instance expected at the
	 *            end of the branch
	 */
	public void put(String[] branch, Typematch leaf) {
		this.service.addInstanceLevelRestriction(
				MergedRestriction.getAllValuesRestriction(branch[branch.length - 1], leaf.getURI()), branch);
	}

	/**
	 * Use this helper method to declare an argument over a Profile, specifying
	 * that the created profile must have, in the given branch of properties, an
	 * instance of the &lt;b&gt;same type&lt;/b&gt; expressed with Typematch argument.
	 * &lt;p/&gt;
	 * Example: &lt;code&gt;
	 * req.put(new String[]{Lighting.PROP_CONTROLS,LightSource.PROP_HAS_TYPE}, new Typematch(ElectricLight.MY_URI));
	 * &lt;/code&gt;
	 *
	 * @param branch
	 *            The path of properties from the Service root class to the
	 *            value to be restricted
	 * @param leaf
	 *            The Typematch describing the type of instance expected at the
	 *            end of the branch
	 */
	public void put(Path branch, Typematch leaf) {
		put(branch.path, leaf);
	}

	/**
	 * Use this helper method to declare an argument over a Profile, specifying
	 * that the created profile must have, in the given branch of properties, an
	 * instance of the &lt;b&gt;same type&lt;/b&gt; expressed with Typematch argument, and
	 * with the specific allowed cardinality.
	 * &lt;p/&gt;
	 * Example: &lt;code&gt;
	 * req.put(new String[]{Lighting.PROP_CONTROLS,LightSource.PROP_HAS_TYPE}, new Typematch(ElectricLight.MY_URI));
	 * &lt;/code&gt;
	 *
	 * @param branch
	 *            The path of properties from the Service root class to the
	 *            value to be restricted
	 * @param leaf
	 *            The Typematch describing the type of instance expected at the
	 *            end of the branch
	 * @param minCard
	 *            Minimum cardinality
	 * @param maxCard
	 *            Maximum cardinality. Must be greater than minimum, of course
	 */
	public void put(Path branch, Typematch leaf, int minCard, int maxCard) {
		this.service.addInstanceLevelRestriction(MergedRestriction.getAllValuesRestrictionWithCardinality(
				branch.path[branch.path.length - 1], leaf.getURI(), maxCard, maxCard), branch.path);
	}

	/**
	 * Use this helper method to declare an argument over a Profile, specifying
	 * that the created profile will receive as &lt;b&gt;variable input&lt;/b&gt;, in the
	 * given branch of properties, &lt;b&gt;an instance of type&lt;/b&gt; expressed with
	 * Variable argument. However it can also be used to specify that the
	 * variable input that can only be handled by this profile is a specific
	 * instance. This can be done by using the byValue constructor of the
	 * Variable.
	 * &lt;p/&gt;
	 * Example: &lt;code&gt;
	 * req.put(new String[]{Lighting.PROP_CONTROLS}, new Variable(LightSource.MY_URI),REF_URI);
	 * &lt;/code&gt;
	 *
	 * @param branch
	 *            The path of properties from the Service root class to the
	 *            value to be received as input by the service
	 * @param leaf
	 *            The Variable describing the type of the value that you want to
	 *            receive as variable input in the service. If it is built with
	 *            a specific instance value then it means that this profile will
	 *            answer only to calls with that value in this variable input.
	 * @param uriID
	 *            The reference URI to be used by the ServiceCallee when dealing
	 *            with this value. Set to null to return an auto-generated one
	 * @return The URI_ID. If it was set to null, it will be automatically
	 *         generated.
	 */
	public String put(String[] branch, Variable leaf, String uriID) {
		// like this.service.addFilteringInput(URI_ID,
		// ManagedIndividual.getTypeURI(leaf.getObject()), 0, 0,branch);
		// only that it's not visible, so we have to make it &quot;manually&quot;
		if (uriID == null) {
			uriID = MY_NAMESPACE + StringUtils.createUniqueID();
		}
		ProcessInput input = new ProcessInput(uriID);
		input.setParameterType(leaf.getURI());
		MergedRestriction restr;
		if (leaf.byURI()) {
			restr = MergedRestriction.getFixedValueRestriction(branch[branch.length - 1], input.asVariableReference());
		} else {
			restr = MergedRestriction.getFixedValueRestriction(branch[branch.length - 1], leaf.getObject());
		}
		this.service.addInstanceLevelRestriction(restr, branch);
		this.service.getProfile().addInput(input);
		return uriID;
	}

	/**
	 * Use this helper method to declare an argument over a Profile, specifying
	 * that the created profile will receive as &lt;b&gt;variable input&lt;/b&gt;, in the
	 * given branch of properties, &lt;b&gt;an instance of type&lt;/b&gt; expressed with
	 * Variable argument. However it can also be used to specify that the
	 * variable input that can only be handled by this profile is a specific
	 * instance. This can be done by using the byValue constructor of the
	 * Variable.
	 * &lt;p/&gt;
	 * Example: &lt;code&gt;
	 * req.put(new String[]{Lighting.PROP_CONTROLS}, new Variable(new LightSource()),REF_URI);
	 * &lt;/code&gt;
	 *
	 * @param branch
	 *            The path of properties from the Service root class to the
	 *            value to be received as input by the service
	 * @param leaf
	 *            The Variable describing the type of the value that you want to
	 *            receive as variable input in the service. If it is built with
	 *            a specific instance value then it means that this profile will
	 *            answer only to calls with that value in this variable input.
	 * @param uriID
	 *            The reference URI to be used by the ServiceCallee when dealing
	 *            with this value. Set to null to return an auto-generated one
	 * @return The URI_ID. If it was set to null, it will be automatically
	 *         generated.
	 */
	public String put(Path branch, Variable leaf, String uriID) {
		return put(branch.path, leaf, uriID);
	}

	/**
	 * Use this helper method to declare an argument over a Profile, specifying
	 * that the created profile will receive as &lt;b&gt;variable input&lt;/b&gt;, in the
	 * given branch of properties, &lt;b&gt;an instance of type&lt;/b&gt; expressed with
	 * Variable argument, and with the specific allowed cardinality. However it
	 * can also be used to specify that the variable input that can only be
	 * handled by this profile is a specific instance. This can be done by using
	 * the byValue constructor of the Variable.
	 * &lt;p/&gt;
	 * Example: &lt;code&gt;
	 * req.put(new String[]{Lighting.PROP_CONTROLS}, new Variable(new LightSource()),REF_URI);
	 * &lt;/code&gt;
	 *
	 * @param branch
	 *            The path of properties from the Service root class to the
	 *            value to be received as input by the service
	 * @param leaf
	 *            The Variable describing the type of the value that you want to
	 *            receive as variable input in the service. If it is built with
	 *            a specific instance value then it means that this profile will
	 *            answer only to calls with that value in this variable input.
	 * @param uriID
	 *            The reference URI to be used by the ServiceCallee when dealing
	 *            with this value. Set to null to return an auto-generated one
	 * @param minCard
	 *            Minimum cardinality
	 * @param maxCard
	 *            Maximum cardinality. Must be greater than minimum, of course
	 * @return The URI_ID. If it was set to null, it will be automatically
	 *         generated.
	 */
	public String put(Path branch, Variable leaf, String uriID, int minCard, int maxCard) {
		if (uriID == null) {
			uriID = MY_NAMESPACE + StringUtils.createUniqueID();
		}
		ProcessInput input = new ProcessInput(uriID);
		input.setParameterType(leaf.getURI());
		input.setCardinality(maxCard, minCard);
		MergedRestriction restr;
		if (leaf.byURI()) {
			restr = MergedRestriction.getFixedValueRestriction(branch.path[branch.path.length - 1],
					input.asVariableReference());
		} else {
			restr = MergedRestriction.getFixedValueRestriction(branch.path[branch.path.length - 1], leaf.getObject());
		}
		this.service.addInstanceLevelRestriction(restr, branch.path);
		this.service.getProfile().addInput(input);
		return uriID;
	}

	/**
	 * Use this helper method to declare an argument over a Profile, specifying
	 * that &lt;b&gt;you will return an output&lt;/b&gt; in the given branch of properties,
	 * and will be of the &lt;b&gt;type&lt;/b&gt; specified with the Output argument.
	 * &lt;p/&gt;
	 * Example: &lt;code&gt;
	 * req.put(new String[]{Lighting.PROP_CONTROLS}, new Output(LightSource.MY_URI));
	 * &lt;/code&gt;
	 *
	 * @param branch
	 *            The path of properties from the Service root class to the
	 *            output that you will return
	 * @param leaf
	 *            The Output describing the type of Output you are returning.
	 *            Take into account that this differs from how it is used in
	 *            Request. Here you must create it with a Type URI (a
	 *            ManagedIndividual.MY_URI).
	 * @param uriID
	 *            The reference URI to be used by the ServiceCallee when dealing
	 *            with this value. Set to null to return an auto-generated one
	 * @return The URI_ID. If it was set to null, it will be automatically
	 *         generated.
	 */
	public String put(String[] branch, Output leaf, String uriID) {
		// like this.service.addOutput(URI_ID, leaf.getURI(), 0, 0, branch);
		// only that it's not visible, so we have to make it &quot;manually&quot;
		if (uriID == null) {
			uriID = MY_NAMESPACE + StringUtils.createUniqueID();
		}
		ProcessOutput output = new ProcessOutput(uriID);
		output.setParameterType(leaf.getURI());
		this.service.getProfile().addOutput(output);
		this.service.getProfile().addSimpleOutputBinding(output, branch);
		return uriID;
	}

	/**
	 * Use this helper method to declare an argument over a Profile, specifying
	 * that &lt;b&gt;you will return an output&lt;/b&gt; in the given branch of properties,
	 * and will be of the &lt;b&gt;type&lt;/b&gt; specified with the Output argument.
	 * &lt;p/&gt;
	 * Example: &lt;code&gt;
	 * req.put(new String[]{Lighting.PROP_CONTROLS}, new Output(LightSource.MY_URI));
	 * &lt;/code&gt;
	 *
	 * @param branch
	 *            The path of properties from the Service root class to the
	 *            output that you will return
	 * @param leaf
	 *            The Output describing the type of Output you are returning.
	 *            Take into account that this differs from how it is used in
	 *            Request. Here you must create it with a Type URI (a
	 *            ManagedIndividual.MY_URI).
	 * @param uriID
	 *            The reference URI to be used by the ServiceCallee when dealing
	 *            with this value. Set to null to return an auto-generated one
	 * @return The URI_ID. If it was set to null, it will be automatically
	 *         generated.
	 */
	public String put(Path branch, Output leaf, String uriID) {
		return put(branch.path, leaf, uriID);
	}

	/**
	 * Use this helper method to declare an argument over a Profile, specifying
	 * that &lt;b&gt;you will return an output&lt;/b&gt; in the given branch of properties,
	 * and will be of the &lt;b&gt;type&lt;/b&gt; specified with the Output argument, and
	 * with the specific allowed cardinality.
	 * &lt;p/&gt;
	 * Example: &lt;code&gt;
	 * req.put(new String[]{Lighting.PROP_CONTROLS}, new Output(LightSource.MY_URI));
	 * &lt;/code&gt;
	 *
	 * @param branch
	 *            The path of properties from the Service root class to the
	 *            output that you will return
	 * @param leaf
	 *            The Output describing the type of Output you are returning.
	 *            Take into account that this differs from how it is used in
	 *            Request. Here you must create it with a Type URI (a
	 *            ManagedIndividual.MY_URI).
	 * @param uriID
	 *            The reference URI to be used by the ServiceCallee when dealing
	 *            with this value. Set to null to return an auto-generated one
	 * @param minCard
	 *            Minimum cardinality
	 * @param maxCard
	 *            Maximum cardinality. Must be greater than minimum, of course
	 * @return The URI_ID. If it was set to null, it will be automatically
	 *         generated.
	 */
	public String put(Path branch, Output leaf, String uriID, int minCard, int maxCard) {
		if (uriID == null) {
			uriID = MY_NAMESPACE + StringUtils.createUniqueID();
		}
		ProcessOutput output = new ProcessOutput(uriID);
		output.setParameterType(leaf.getURI());
		output.setCardinality(maxCard, minCard);
		this.service.getProfile().addOutput(output);
		this.service.getProfile().addSimpleOutputBinding(output, branch.path);
		return uriID;
	}

	/**
	 * Use this helper method to declare an argument over a Profile, specifying
	 * that you will &lt;b&gt;add&lt;/b&gt;, in the given branch of properties, a &lt;b&gt;value
	 * instance of type&lt;/b&gt; expressed with Add argument. However it can also be
	 * used to specify that the added input that can only be handled by this
	 * profile is a specific instance. This can be done by using the byValue
	 * constructor of the Add.
	 * &lt;p/&gt;
	 * Example: &lt;code&gt;
	 * req.put(new String[]{Lighting.PROP_CONTROLS}, new Add(new LightSource()));
	 * &lt;/code&gt;
	 *
	 * @param branch
	 *            The path of properties from the Service root class to the
	 *            value to be added
	 * @param leaf
	 *            The Add describing the type of instance to be added at the end
	 *            of the branch. If it is built with a specific instance value
	 *            then it means that this profile will answer only to calls with
	 *            that value in this added input.
	 * @param uriID
	 *            The reference URI to be used by the ServiceCallee when dealing
	 *            with this value. Set to null to return an auto-generated one
	 * @return The URI_ID. If it was set to null, it will be automatically
	 *         generated.
	 */
	public String put(String[] branch, Add leaf, String uriID) {
		// like this.service.addInputWithAddEffect(URI_ID,
		// ManagedIndividual.getTypeURI(leaf.getObject()), 0, 0,branch);
		// only that it's not visible, so we have to make it &quot;manually&quot;
		if (uriID == null) {
			uriID = MY_NAMESPACE + StringUtils.createUniqueID();
		}
		ProcessInput input = new ProcessInput(uriID);
		input.setParameterType(leaf.getURI());
		this.service.getProfile().addInput(input);
		if (leaf.byURI()) {
			this.service.getProfile().addAddEffect(branch, input.asVariableReference());
		} else {
			this.service.getProfile().addAddEffect(branch, leaf.getObject());
		}
		return uriID;
	}

	/**
	 * Use this helper method to declare an argument over a Profile, specifying
	 * that you will &lt;b&gt;add&lt;/b&gt;, in the given branch of properties, a &lt;b&gt;value
	 * instance of type&lt;/b&gt; expressed with Add argument. However it can also be
	 * used to specify that the added input that can only be handled by this
	 * profile is a specific instance. This can be done by using the byValue
	 * constructor of the Add.
	 * &lt;p/&gt;
	 * Example: &lt;code&gt;
	 * req.put(new String[]{Lighting.PROP_CONTROLS}, new Add(new LightSource()));
	 * &lt;/code&gt;
	 *
	 * @param branch
	 *            The path of properties from the Service root class to the
	 *            value to be added
	 * @param leaf
	 *            The Add describing the type of instance to be added at the end
	 *            of the branch. If it is built with a specific instance value
	 *            then it means that this profile will answer only to calls with
	 *            that value in this added input.
	 * @param uriID
	 *            The reference URI to be used by the ServiceCallee when dealing
	 *            with this value. Set to null to return an auto-generated one
	 * @return The URI_ID. If it was set to null, it will be automatically
	 *         generated.
	 */
	public String put(Path branch, Add leaf, String uriID) {
		return put(branch.path, leaf, uriID);
	}

	/**
	 * Use this helper method to declare an argument over a Profile, specifying
	 * that you will &lt;b&gt;add&lt;/b&gt;, in the given branch of properties, a &lt;b&gt;value
	 * instance of type&lt;/b&gt; expressed with Add argument, and with the specific
	 * allowed cardinality. However it can also be used to specify that the
	 * added input that can only be handled by this profile is a specific
	 * instance. This can be done by using the byValue constructor of the Add.
	 * &lt;p/&gt;
	 * Example: &lt;code&gt;
	 * req.put(new String[]{Lighting.PROP_CONTROLS}, new Add(new LightSource()));
	 * &lt;/code&gt;
	 *
	 * @param branch
	 *            The path of properties from the Service root class to the
	 *            value to be added
	 * @param leaf
	 *            The Add describing the type of instance to be added at the end
	 *            of the branch. If it is built with a specific instance value
	 *            then it means that this profile will answer only to calls with
	 *            that value in this added input.
	 * @param uriID
	 *            The reference URI to be used by the ServiceCallee when dealing
	 *            with this value. Set to null to return an auto-generated one
	 * @param minCard
	 *            Minimum cardinality
	 * @param maxCard
	 *            Maximum cardinality. Must be greater than minimum, of course
	 * @return The URI_ID. If it was set to null, it will be automatically
	 *         generated.
	 */
	public String put(Path branch, Add leaf, String uriID, int minCard, int maxCard) {
		if (uriID == null) {
			uriID = MY_NAMESPACE + StringUtils.createUniqueID();
		}
		ProcessInput input = new ProcessInput(uriID);
		input.setParameterType(leaf.getURI());
		input.setCardinality(maxCard, minCard);
		this.service.getProfile().addInput(input);
		if (leaf.byURI()) {
			this.service.getProfile().addAddEffect(branch.path, input.asVariableReference());
		} else {
			this.service.getProfile().addAddEffect(branch.path, leaf.getObject());
		}
		return uriID;
	}

	/**
	 * Use this helper method to declare an argument over a Profile, specifying
	 * that you will &lt;b&gt;remove&lt;/b&gt;, from the given branch of properties, &lt;b&gt;a
	 * value instance of type&lt;/b&gt; expressed with Remove argument. However it can
	 * also be used to specify that the removed input that can only be handled
	 * by this profile is a specific instance. This can be done by using the
	 * byValue constructor of the Remove.
	 * &lt;p/&gt;
	 * Example: &lt;code&gt;
	 * req.put(new String[]{Lighting.PROP_CONTROLS}, new Remove(new LightSource()));
	 * &lt;/code&gt;
	 *
	 * @param branch
	 *            The path of properties from the Service root class to the
	 *            value to be removed
	 * @param leaf
	 *            The Remove describing the type of instance to be removed at
	 *            the end of the branch. If it is built with a specific instance
	 *            value then it means that this profile will answer only to
	 *            calls with that value in this removed input.
	 * @param uriID
	 *            The reference URI to be used by the ServiceCallee when dealing
	 *            with this value. Set to null to return an auto-generated one
	 * @return The URI_ID. If it was set to null, it will be automatically
	 *         generated.
	 */
	public String put(String[] branch, Remove leaf, String uriID) {
		// like this.service.addInputWithRemoveEffect(URI_ID,
		// ManagedIndividual.getTypeURI(leaf.getObject()), 0, 0,branch);
		// only that it's not visible, so we have to make it &quot;manually&quot;
		if (uriID == null) {
			uriID = MY_NAMESPACE + StringUtils.createUniqueID();
		}
		ProcessInput input = new ProcessInput(uriID);
		input.setParameterType(leaf.getURI());
		this.service.getProfile().addInput(input);
		// TODO The addRemoveEffect does not take value to remove!!! Will this
		// work?
		MergedRestriction restr;
		if (leaf.byURI()) {
			restr = MergedRestriction.getFixedValueRestriction(branch[branch.length - 1], input.asVariableReference());
		} else {
			restr = MergedRestriction.getFixedValueRestriction(branch[branch.length - 1], leaf.getObject());
		}
		this.service.addInstanceLevelRestriction(restr, branch);
		this.service.getProfile().addRemoveEffect(branch);
		return uriID;
	}

	/**
	 * Use this helper method to declare an argument over a Profile, specifying
	 * that you will &lt;b&gt;remove&lt;/b&gt;, from the given branch of properties, &lt;b&gt;a
	 * value instance of type&lt;/b&gt; expressed with Remove argument. However it can
	 * also be used to specify that the removed input that can only be handled
	 * by this profile is a specific instance. This can be done by using the
	 * byValue constructor of the Remove.
	 * &lt;p/&gt;
	 * Example: &lt;code&gt;
	 * req.put(new String[]{Lighting.PROP_CONTROLS}, new Remove(new LightSource()));
	 * &lt;/code&gt;
	 *
	 * @param branch
	 *            The path of properties from the Service root class to the
	 *            value to be removed
	 * @param leaf
	 *            The Remove describing the type of instance to be removed at
	 *            the end of the branch. If it is built with a specific instance
	 *            value then it means that this profile will answer only to
	 *            calls with that value in this removed input.
	 * @param uriID
	 *            The reference URI to be used by the ServiceCallee when dealing
	 *            with this value. Set to null to return an auto-generated one
	 * @return The URI_ID. If it was set to null, it will be automatically
	 *         generated.
	 */
	public String put(Path branch, Remove leaf, String uriID) {
		return put(branch.path, leaf, uriID);
	}

	/**
	 * Use this helper method to declare an argument over a Profile, specifying
	 * that you will &lt;b&gt;remove&lt;/b&gt;, from the given branch of properties, &lt;b&gt;a
	 * value instance of type&lt;/b&gt; expressed with Remove argument, and with the
	 * specific allowed cardinality. However it can also be used to specify that
	 * the removed input that can only be handled by this profile is a specific
	 * instance. This can be done by using the byValue constructor of the
	 * Remove.
	 * &lt;p/&gt;
	 * Example: &lt;code&gt;
	 * req.put(new String[]{Lighting.PROP_CONTROLS}, new Remove(new LightSource()));
	 * &lt;/code&gt;
	 *
	 * @param branch
	 *            The path of properties from the Service root class to the
	 *            value to be removed
	 * @param leaf
	 *            The Remove describing the type of instance to be removed at
	 *            the end of the branch. If it is built with a specific instance
	 *            value then it means that this profile will answer only to
	 *            calls with that value in this removed input.
	 * @param uriID
	 *            The reference URI to be used by the ServiceCallee when dealing
	 *            with this value. Set to null to return an auto-generated one
	 * @param minCard
	 *            Minimum cardinality
	 * @param maxCard
	 *            Maximum cardinality. Must be greater than minimum, of course
	 * @return The URI_ID. If it was set to null, it will be automatically
	 *         generated.
	 */
	public String put(Path branch, Remove leaf, String uriID, int minCard, int maxCard) {
		if (uriID == null) {
			uriID = MY_NAMESPACE + StringUtils.createUniqueID();
		}
		ProcessInput input = new ProcessInput(uriID);
		input.setParameterType(leaf.getURI());
		input.setCardinality(maxCard, minCard);
		this.service.getProfile().addInput(input);
		MergedRestriction restr;
		if (leaf.byURI()) {
			restr = MergedRestriction.getFixedValueRestriction(branch.path[branch.path.length - 1],
					input.asVariableReference());
		} else {
			restr = MergedRestriction.getFixedValueRestriction(branch.path[branch.path.length - 1], leaf.getObject());
		}
		this.service.addInstanceLevelRestriction(restr, branch.path);
		this.service.getProfile().addRemoveEffect(branch.path);
		return uriID;
	}

	/**
	 * Use this helper method to declare an argument over a Profile, specifying
	 * that you will &lt;b&gt;change&lt;/b&gt;, at the given branch of properties, an old
	 * value with &lt;b&gt;the new one&lt;/b&gt;, an instance of type expressed with Change
	 * argument. However it can also be used to specify that the changed input
	 * that can only be handled by this profile is a specific instance. This can
	 * be done by using the byValue constructor of the Change.
	 * &lt;p/&gt;
	 * Example: &lt;code&gt;
	 * req.put(new String[]{Lighting.PROP_CONTROLS,LightSource.PROP_SOURCE_BRIGHTNESS }, new Change(new Integer(0)));
	 * &lt;/code&gt;
	 *
	 * @param branch
	 *            The path of properties from the Service root class to the
	 *            value to be changed
	 * @param leaf
	 *            The Change describing the type of instance to be changed at
	 *            the end of the branch. If it is built with a specific instance
	 *            value then it means that this profile will answer only to
	 *            calls with that value in this changed input.
	 * @param uriID
	 *            The reference URI to be used by the ServiceCallee when dealing
	 *            with this value. Set to null to return an auto-generated one
	 * @return The URI_ID. If it was set to null, it will be automatically
	 *         generated.
	 */
	public String put(String[] branch, Change leaf, String uriID) {
		// like this.service.addInputWithChangeEffect(URI_ID,
		// ManagedIndividual.getTypeURI(leaf.getObject()), 0, 0,branch);
		// only that it's not visible, so we have to make it &quot;manually&quot;
		if (uriID == null) {
			uriID = MY_NAMESPACE + StringUtils.createUniqueID();
		}
		ProcessInput input = new ProcessInput(uriID);
		input.setParameterType(leaf.getURI());
		this.service.getProfile().addInput(input);
		if (leaf.byURI()) {
			this.service.getProfile().addChangeEffect(branch, input.asVariableReference());
		} else {
			this.service.getProfile().addChangeEffect(branch, leaf.getObject());
		}
		return uriID;
	}

	/**
	 * Use this helper method to declare an argument over a Profile, specifying
	 * that you will &lt;b&gt;change&lt;/b&gt;, at the given branch of properties, an old
	 * value with &lt;b&gt;the new one&lt;/b&gt;, an instance of type expressed with Change
	 * argument. However it can also be used to specify that the changed input
	 * that can only be handled by this profile is a specific instance. This can
	 * be done by using the byValue constructor of the Change.
	 * &lt;p/&gt;
	 * Example: &lt;code&gt;
	 * req.put(new String[]{Lighting.PROP_CONTROLS,LightSource.PROP_SOURCE_BRIGHTNESS }, new Change(new Integer(0)));
	 * &lt;/code&gt;
	 *
	 * @param branch
	 *            The path of properties from the Service root class to the
	 *            value to be changed
	 * @param leaf
	 *            The Change describing the type of instance to be changed at
	 *            the end of the branch. If it is built with a specific instance
	 *            value then it means that this profile will answer only to
	 *            calls with that value in this changed input.
	 * @param uriID
	 *            The reference URI to be used by the ServiceCallee when dealing
	 *            with this value. Set to null to return an auto-generated one
	 * @return The URI_ID. If it was set to null, it will be automatically
	 *         generated.
	 */
	public String put(Path branch, Change leaf, String uriID) {
		return put(branch.path, leaf, uriID);
	}

	/**
	 * Use this helper method to declare an argument over a Profile, specifying
	 * that you will &lt;b&gt;change&lt;/b&gt;, at the given branch of properties, an old
	 * value with &lt;b&gt;the new one&lt;/b&gt;, an instance of type expressed with Change
	 * argument, and with the specific allowed cardinality. However it can also
	 * be used to specify that the changed input that can only be handled by
	 * this profile is a specific instance. This can be done by using the
	 * byValue constructor of the Change.
	 * &lt;p/&gt;
	 * Example: &lt;code&gt;
	 * req.put(new String[]{Lighting.PROP_CONTROLS,LightSource.PROP_SOURCE_BRIGHTNESS }, new Change(new Integer(0)));
	 * &lt;/code&gt;
	 *
	 * @param branch
	 *            The path of properties from the Service root class to the
	 *            value to be changed
	 * @param leaf
	 *            The Change describing the type of instance to be changed at
	 *            the end of the branch. If it is built with a specific instance
	 *            value then it means that this profile will answer only to
	 *            calls with that value in this changed input.
	 * @param uriID
	 *            The reference URI to be used by the ServiceCallee when dealing
	 *            with this value. Set to null to return an auto-generated one
	 * @param minCard
	 *            Minimum cardinality
	 * @param maxCard
	 *            Maximum cardinality. Must be greater than minimum, of course
	 * @return The URI_ID. If it was set to null, it will be automatically
	 *         generated.
	 */
	public String put(Path branch, Change leaf, String uriID, int minCard, int maxCard) {
		if (uriID == null) {
			uriID = MY_NAMESPACE + StringUtils.createUniqueID();
		}
		ProcessInput input = new ProcessInput(uriID);
		input.setParameterType(leaf.getURI());
		input.setCardinality(maxCard, minCard);
		this.service.getProfile().addInput(input);
		if (leaf.byURI()) {
			this.service.getProfile().addChangeEffect(branch.path, input.asVariableReference());
		} else {
			this.service.getProfile().addChangeEffect(branch.path, leaf.getObject());
		}
		return uriID;
	}

	/**
	 * Use this method when you are done defining your Profile in order to get
	 * the actual ServiceProfile that you can use in your ProvidedService class.
	 * Assign the returned ServiceProfile to a value of the &quot;profiles&quot; array of
	 * that class. Or you can use it first to add it more restrictions or
	 * arguments the old-fashioned way.
	 *
	 * @return The resulting ServiceProfile of this Profile
	 */
	public ServiceProfile getTheProfile() {
		return this.service.getProfile();
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/service/mid/UtilEditor.java</td>
<td>universAAL Support Utilities API</td>
<td>50</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/service/mid/UtilEditor.java</td>
<td>universAAL Utilities APIs</td>
<td>50</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class UtilEditor {
	/**
	 * Service suffix.
	 */
	public static final String SERVICE_GET = &quot;servEditorGet&quot;;
	/**
	 * Service suffix.
	 */
	public static final String SERVICE_ADD = &quot;servEditorAdd&quot;;
	/**
	 * Service suffix.
	 */
	public static final String SERVICE_CHANGE = &quot;servEditorChange&quot;;
	/**
	 * Service suffix.
	 */
	public static final String SERVICE_REMOVE = &quot;servEditorRemove&quot;;
	/**
	 * Argument suffix.
	 */
	public static final String FAKE_URI = &quot;placeholderURI&quot;;
	/**
	 * Argument suffix.
	 */
	public static final String IN_GET = &quot;inputEditorGet&quot;;
	/**
	 * Argument suffix.
	 */
	public static final String OUT_GET = &quot;outputEditorGet&quot;;
	/**
	 * Argument suffix.
	 */
	public static final String IN_ADD = &quot;inputEditorAdd&quot;;
	/**
	 * Argument suffix.
	 */
	public static final String IN_CHANGE = &quot;inputEditorChange&quot;;
	/**
	 * Argument suffix.
	 */
	public static final String IN_REMOVE = &quot;inputEditorRemove&quot;;

	/**
	 * Gives you the 4 typical service profiles of an editor service: Get, Add,
	 * Change and Remove. When handling requests in you Callee, you can use the
	 * references to services and arguments URIs prepending
	 * &lt;code&gt;namespace&lt;/code&gt; to UtilEditor constants.
	 * &lt;p&gt;
	 * Example:
	 * &lt;p&gt;
	 * &lt;code&gt;
	 * new SCallee(context, getServiceProfiles(&quot;http://ontology.universAAL.org/ProfilingServer.owl#&quot;, ProfilingService.MY_URI, Path.start(ProfilingService.PROP_CONTROLS).path, Profilable.MY_URI))
	 * &lt;/code&gt;
	 * &lt;p&gt;
	 *
	 * @param namespace
	 *            The namespace of your server, ending with the character #. You
	 *            can optionally add some prefix after the # if you use
	 *            UtilEditor more than once in the same Callee.
	 * @param ontologyURI
	 *            The MY_URI of the class of Service ontology you are going to
	 *            implement
	 * @param path
	 *            The property path from the root of the Service ontology
	 *            concept to the exact concept you want to manage
	 * @param editedURI
	 *            The MY_URI of the class of the concept ontology that you want
	 *            to manage, which is at the end of the property path
	 * @return An array with the 4 typical service profiles
	 */
	public static ServiceProfile[] getServiceProfiles(String namespace, String ontologyURI, String[] path,
			String editedURI) {

		ServiceProfile[] profiles = new ServiceProfile[4];
		// This, and the usage of Arg.s do not work when editedURI are of
		// abstract ont classes. Because they cannot be instantiated.
		// Resource argument = OntologyManagement.getInstance().getResource(
		// editedURI, FAKE_URI);

		// Get
		Profile prof1 = new Profile(
				(Service) OntologyManagement.getInstance().getResource(ontologyURI, namespace + SERVICE_GET));
		// prof1.put(path, Arg.in(argument), namespace + IN_GET);
		ProcessInput input1 = new ProcessInput(namespace + IN_GET);
		input1.setParameterType(editedURI);
		input1.setCardinality(1, 1);
		MergedRestriction restr1 = MergedRestriction.getFixedValueRestriction(path[path.length - 1],
				input1.asVariableReference());
		prof1.service.addInstanceLevelRestriction(restr1, path);
		prof1.service.getProfile().addInput(input1);
		// prof1.put(path, Arg.out(argument), namespace + OUT_GET);
		ProcessOutput output = new ProcessOutput(namespace + OUT_GET);
		output.setParameterType(editedURI);
		prof1.service.getProfile().addOutput(output);
		prof1.service.getProfile().addSimpleOutputBinding(output, path);
		profiles[0] = prof1.getTheProfile();

		// Add
		Profile prof2 = new Profile(
				(Service) OntologyManagement.getInstance().getResource(ontologyURI, namespace + SERVICE_ADD));
		// prof2.put(path, Arg.add(argument), namespace + IN_ADD);
		ProcessInput input2 = new ProcessInput(namespace + IN_ADD);
		input2.setParameterType(editedURI);
		input2.setCardinality(1, 1);
		prof2.service.getProfile().addInput(input2);
		prof2.service.getProfile().addAddEffect(path, input2.asVariableReference());
		profiles[1] = prof2.getTheProfile();

		// Change
		Profile prof3 = new Profile(
				(Service) OntologyManagement.getInstance().getResource(ontologyURI, namespace + SERVICE_CHANGE));
		// prof3.put(path, Arg.change(argument), namespace + IN_CHANGE);
		ProcessInput input3 = new ProcessInput(namespace + IN_CHANGE);
		input3.setCardinality(1, 1);
		input3.setParameterType(editedURI);
		prof3.service.getProfile().addInput(input3);
		prof3.service.getProfile().addChangeEffect(path, input3.asVariableReference());
		profiles[2] = prof3.getTheProfile();

		// Remove
		Profile prof4 = new Profile(
				(Service) OntologyManagement.getInstance().getResource(ontologyURI, namespace + SERVICE_REMOVE));
		// prof4.put(path, Arg.remove(argument), namespace + IN_REMOVE);
		ProcessInput input4 = new ProcessInput(namespace + IN_REMOVE);
		input4.setParameterType(editedURI);
		input4.setCardinality(1, 1);
		prof4.service.getProfile().addInput(input4);
		MergedRestriction restr4 = MergedRestriction.getFixedValueRestriction(path[path.length - 1],
				input4.asVariableReference());
		prof4.service.addInstanceLevelRestriction(restr4, path);
		prof4.service.getProfile().addRemoveEffect(path);
		profiles[3] = prof4.getTheProfile();

		return profiles;
	}

	/**
	 * Gives you the typical GET service request for editor services. If the
	 * editor service also used UtilEditor the match is guaranteed.
	 *
	 * @param ontologyURI
	 *            The MY_URI of the class of Service ontology you want to call
	 * @param path
	 *            The property path from the root of the Service ontology
	 *            concept to the exact concept you want to manage
	 * @param argIn
	 *            Value representing the input you want to pass as parameter.
	 *            The editor GET service will return you the full Resource with
	 *            the URI of this argument.
	 * @param argOut
	 *            The returned value of the editor GET service will be placed in
	 *            the URI represented by this Output. Look for it there in the
	 *            response.
	 * @return The ServiceRequest that will call the matching GET service of an
	 *         editor
	 */
	public static ServiceRequest requestGet(String ontologyURI, String[] path, Variable argIn, Output argOut) {
		Request req = new Request((Service) OntologyManagement.getInstance().getResource(ontologyURI, null));
		req.put(path, argIn);
		req.put(path, argOut);
		return req;
	}

	/**
	 * Gives you the typical GET service request for editor services. If the
	 * editor service also used UtilEditor the match is guaranteed.
	 *
	 * @param ontologyURI
	 *            The MY_URI of the class of Service ontology you want to call
	 * @param path
	 *            The property path from the root of the Service ontology
	 *            concept to the exact concept you want to manage
	 * @param in
	 *            Object representing the input you want to pass as parameter.
	 *            The editor GET service will return you the full Resource with
	 *            the URI of this argument.
	 * @param out
	 *            The returned value of the editor GET service will be placed in
	 *            this URI. Look for it there in the response.
	 * @return The ServiceRequest that will call the matching GET service of an
	 *         editor
	 */
	public static ServiceRequest requestGet(String ontologyURI, String[] path, Object in, String out) {
		Request req = new Request((Service) OntologyManagement.getInstance().getResource(ontologyURI, null));
		req.put(path, Arg.in(in));
		req.put(path, Arg.out(out));
		return req;
	}

	/**
	 * Gives you the typical ADD service request for editor services. If the
	 * editor service also used UtilEditor the match is guaranteed.
	 *
	 * @param ontologyURI
	 *            The MY_URI of the class of Service ontology you want to call
	 * @param path
	 *            The property path from the root of the Service ontology
	 *            concept to the exact concept you want to manage
	 * @param argAdd
	 *            Add representing the input you want to pass as parameter. The
	 *            editor ADD service will add the full Resource passed in this
	 *            argument.
	 * @return The ServiceRequest that will call the matching ADD service of an
	 *         editor
	 */
	public static ServiceRequest requestAdd(String ontologyURI, String[] path, Add argAdd) {
		Request req = new Request((Service) OntologyManagement.getInstance().getResource(ontologyURI, null));
		req.put(path, argAdd);
		return req;
	}

	/**
	 * Gives you the typical ADD service request for editor services. If the
	 * editor service also used UtilEditor the match is guaranteed.
	 *
	 * @param ontologyURI
	 *            The MY_URI of the class of Service ontology you want to call
	 * @param path
	 *            The property path from the root of the Service ontology
	 *            concept to the exact concept you want to manage
	 * @param add
	 *            Object representing the input you want to pass as parameter.
	 *            The editor ADD service will add the full Resource passed in
	 *            this argument.
	 * @return The ServiceRequest that will call the matching ADD service of an
	 *         editor
	 */
	public static ServiceRequest requestAdd(String ontologyURI, String[] path, Object add) {
		Request req = new Request((Service) OntologyManagement.getInstance().getResource(ontologyURI, null));
		req.put(path, Arg.add(add));
		return req;
	}

	/**
	 * Gives you the typical CHANGE service request for editor services. If the
	 * editor service also used UtilEditor the match is guaranteed.
	 *
	 * @param ontologyURI
	 *            The MY_URI of the class of Service ontology you want to call
	 * @param path
	 *            The property path from the root of the Service ontology
	 *            concept to the exact concept you want to manage
	 * @param argChange
	 *            Change representing the input you want to pass as parameter.
	 *            The editor CHANGE service will replace the Resource of the
	 *            same URI with this new value
	 * @return The ServiceRequest that will call the matching CHANGE service of
	 *         an editor
	 */
	public static ServiceRequest requestChange(String ontologyURI, String[] path, Change argChange) {
		Request req = new Request((Service) OntologyManagement.getInstance().getResource(ontologyURI, null));
		req.put(path, argChange);
		return req;
	}

	/**
	 * Gives you the typical CHANGE service request for editor services. If the
	 * editor service also used UtilEditor the match is guaranteed.
	 *
	 * @param ontologyURI
	 *            The MY_URI of the class of Service ontology you want to call
	 * @param path
	 *            The property path from the root of the Service ontology
	 *            concept to the exact concept you want to manage
	 * @param change
	 *            Object representing the input you want to pass as parameter.
	 *            The editor CHANGE service will replace the Resource of the
	 *            same URI with this new value
	 * @return The ServiceRequest that will call the matching CHANGE service of
	 *         an editor
	 */
	public static ServiceRequest requestChange(String ontologyURI, String[] path, Object change) {
		Request req = new Request((Service) OntologyManagement.getInstance().getResource(ontologyURI, null));
		req.put(path, Arg.change(change));
		return req;
	}

	/**
	 * Gives you the typical REMOVE service request for editor services. If the
	 * editor service also used UtilEditor the match is guaranteed.
	 *
	 * @param ontologyURI
	 *            The MY_URI of the class of Service ontology you want to call
	 * @param path
	 *            The property path from the root of the Service ontology
	 *            concept to the exact concept you want to manage
	 * @param argRemove
	 *            Object representing the input you want to pass as parameter.
	 *            The editor REMOVE service will remove all occurences of the
	 *            Resource of the same URI of this argument
	 * @return The ServiceRequest that will call the matching CHANGE service of
	 *         an editor
	 */
	public static ServiceRequest requestRemove(String ontologyURI, String[] path, Remove argRemove) {
		Request req = new Request((Service) OntologyManagement.getInstance().getResource(ontologyURI, null));
		req.put(path, argRemove);
		return req;
	}

	/**
	 * Gives you the typical REMOVE service request for editor services. If the
	 * editor service also used UtilEditor the match is guaranteed.
	 *
	 * @param ontologyURI
	 *            The MY_URI of the class of Service ontology you want to call
	 * @param path
	 *            The property path from the root of the Service ontology
	 *            concept to the exact concept you want to manage
	 * @param remove
	 *            Object representing the input you want to pass as parameter.
	 *            The editor REMOVE service will remove all occurences of the
	 *            Resource of the same URI of this object
	 * @return The ServiceRequest that will call the matching CHANGE service of
	 *         an editor
	 */
	public static ServiceRequest requestRemove(String ontologyURI, String[] path, Object remove) {
		Request req = new Request((Service) OntologyManagement.getInstance().getResource(ontologyURI, null));
		req.put(path, Arg.remove(remove));
		return req;
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/service/mid/UtilActuator.java</td>
<td>universAAL Support Utilities API</td>
<td>52</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/service/mid/UtilActuator.java</td>
<td>universAAL Utilities APIs</td>
<td>52</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class UtilActuator {

	/**
	 * Service suffix.
	 */
	public static final String SERVICE_GET_ON_OFF = &quot;servActuatorGet&quot;;
	/**
	 * Argument suffix.
	 */
	public static final String OUT_GET_ON_OFF = &quot;outputActuatorGet&quot;;
	/**
	 * Service suffix.
	 */
	public static final String SERVICE_TURN_OFF = &quot;servActuatorOff&quot;;
	/**
	 * Service suffix.
	 */
	public static final String SERVICE_TURN_ON = &quot;servActuatorOn&quot;;
	/**
	 * Argument suffix.
	 */
	public static final String IN_DEVICE = &quot;inputActuatorAll&quot;;

	/**
	 * Gives you the 3 typical service profiles of an on/off actuator service:
	 * Get status, Set On, and Set Off. When handling requests in your Callee,
	 * you can use the references to services and arguments URIs prepending
	 * &lt;code&gt;namespace&lt;/code&gt; to UtilActuator constants.
	 * &lt;p&gt;
	 * BE CAREFUL: This will only work with actuators that have StatusValue as
	 * HAS_VALUE property. Others, like DimmerActuator, will throw an exception.
	 * &lt;p&gt;
	 * Example:
	 * &lt;p&gt;
	 * &lt;code&gt;
	 * new SCallee(context, getServiceProfiles(&quot;http://ontology.universAAL.org/OvenServer.owl#&quot;, OvenService.MY_URI, myOvenDevice))
	 * &lt;/code&gt;
	 * &lt;p&gt;
	 *
	 * @param namespace
	 *            The namespace of your server, ending with the character #. You
	 *            can optionally add some prefix after the # if you use
	 *            UtilActuator more than once in the same Callee.
	 * @param ontologyURI
	 *            The MY_URI of the class of DeviceService ontology you are
	 *            going to implement. It MUST be a subclass of DeviceService.
	 * @param actuator
	 *            The ontology instance of the actuator you are controlling. The
	 *            more properties it has set, the better.
	 * @return An array with the 3 typical service profiles
	 * @throws InvalidOntologyUtilException
	 *             when an actuator is passed that is does not have StatusValue
	 *             as type restriction of its HAS_VALUE property.
	 */
	public static ServiceProfile[] getServiceProfiles(String namespace, String ontologyURI, Actuator actuator)
			throws InvalidOntologyUtilException {

		try {
			if (actuator.getOntClassInfo().getRestrictionsOnProp(Actuator.PROP_HAS_VALUE).getPropTypeURI()
					.equals(StatusValue.MY_URI)) {
				throw new InvalidOntologyUtilException(&quot;The Actuator ontology passed as parameter &quot;
						+ &quot;is not an on/off Actuator: its HAS_VALUE&quot; + &quot; property must be of type StatusValue&quot;);
			}
		} catch (NullPointerException e) {
			throw new InvalidOntologyUtilException(&quot;The Actuator ontology passed as parameter&quot;
					+ &quot; misses some restriction on its HAS_VALUE&quot; + &quot; property. It must be of type StatusValue&quot;);
		}

		ServiceProfile[] profiles = new ServiceProfile[3];

		PropertyPath ppath = new PropertyPath(null, true,
				new String[] { DeviceService.PROP_CONTROLS, Actuator.PROP_HAS_VALUE });

		ProcessInput input = new ProcessInput(namespace + IN_DEVICE);
		input.setParameterType(actuator.getClassURI());
		input.setCardinality(1, 0);

		MergedRestriction r = MergedRestriction.getFixedValueRestriction(DeviceService.PROP_CONTROLS, actuator);

		Service getOnOff = (Service) OntologyManagement.getInstance().getResource(ontologyURI,
				namespace + SERVICE_GET_ON_OFF);
		profiles[0] = getOnOff.getProfile();
		ProcessOutput output = new ProcessOutput(namespace + OUT_GET_ON_OFF);
		output.setCardinality(1, 1);
		profiles[0].addOutput(output);
		profiles[0].addSimpleOutputBinding(output, ppath.getThePath());
		profiles[0].addInput(input);
		profiles[0].getTheService().addInstanceLevelRestriction(r, new String[] { DeviceService.PROP_CONTROLS });

		Service turnOff = (Service) OntologyManagement.getInstance().getResource(ontologyURI,
				namespace + SERVICE_TURN_OFF);
		profiles[1] = turnOff.getProfile();
		profiles[1].addChangeEffect(ppath.getThePath(), StatusValue.NotActivated);
		profiles[1].addInput(input);
		profiles[1].getTheService().addInstanceLevelRestriction(r, new String[] { DeviceService.PROP_CONTROLS });

		Service turnOn = (Service) OntologyManagement.getInstance().getResource(ontologyURI,
				namespace + SERVICE_TURN_ON);
		profiles[2] = turnOn.getProfile();
		profiles[2].addChangeEffect(ppath.getThePath(), StatusValue.Activated);
		profiles[2].addInput(input);
		profiles[2].getTheService().addInstanceLevelRestriction(r, new String[] { DeviceService.PROP_CONTROLS });

		return profiles;
	}

	/**
	 * Gives you the 3 typical service profiles of an on/off actuator service:
	 * Get status, Set On, and Set Off. When handling requests in your Callee,
	 * you can use the references to services and arguments URIs prepending
	 * &lt;code&gt;namespace&lt;/code&gt; to UtilActuator constants. The service is treated
	 * as the default DeviceService, in case you don't have a specific service
	 * ontology for the type of actuator you are handling.
	 * &lt;p&gt;
	 * BE CAREFUL: This will only work with actuators that have StatusValue as
	 * HAS_VALUE property. Others, like DimmerActuator, will throw an exception.
	 *
	 * @param namespace
	 *            The namespace of your server, ending with the character #. You
	 *            can optionally add some prefix after the # if you use
	 *            UtilActuator more than once in the same Callee.
	 * @param actuator
	 *            The ontology instance of the actuator you are controlling. The
	 *            more properties it has set, the better.
	 * @return An array with the 3 typical service profiles
	 * @throws InvalidOntologyUtilException
	 *             when an actuator is passed that is does not have StatusValue
	 *             as type restriction of its HAS_VALUE property
	 */
	public static ServiceProfile[] getServiceProfiles(String namespace, Actuator actuator)
			throws InvalidOntologyUtilException {
		return getServiceProfiles(namespace, DeviceService.MY_URI, actuator);
	}

	/**
	 * Gives you the typical GET STATUS service request for actuator services.
	 * If the editor service also used UtilActuator the match is guaranteed.
	 *
	 * @param ontologyURI
	 *            The MY_URI of the class of Service ontology you want to call
	 * @param argIn
	 *            Value representing the input you want to pass as parameter.
	 *            The actuator GET service will be called for this specific
	 *            actuator.
	 * @param argOut
	 *            The returned value of the actuator GET service will be placed
	 *            in the URI represented by this Output. Look for it there in
	 *            the response.
	 * @return The ServiceRequest that will call the matching GET STATUS service
	 *         of an actuator
	 */
	public static ServiceRequest requestGetOnOff(String ontologyURI, Variable argIn, Output argOut) {
		Request req = new Request((Service) OntologyManagement.getInstance().getResource(ontologyURI, null));
		req.put(Path.at(DeviceService.PROP_CONTROLS), argIn);
		req.put(Path.at(DeviceService.PROP_CONTROLS).to(Actuator.PROP_HAS_VALUE), argOut);
		return req;
	}

	/**
	 * Gives you the typical GET STATUS service request for actuator services.
	 * If the editor service also used UtilActuator the match is guaranteed.
	 *
	 * @param ontologyURI
	 *            The MY_URI of the class of Service ontology you want to call
	 * @param actuator
	 *            The ontology instance of the actuator you want to get the
	 *            status from.
	 * @param out
	 *            The returned value of the actuator GET service will be placed
	 *            in the URI represented by this String. Look for it there in
	 *            the response.
	 * @return The ServiceRequest that will call the matching GET STATUS service
	 *         of an actuator
	 */
	public static ServiceRequest requestGetOnOff(String ontologyURI, Actuator actuator, String out) {
		return requestGetOnOff(ontologyURI, Arg.in(actuator), Arg.out(out));
	}

	/**
	 * Gives you the typical GET STATUS service request for actuator services.
	 * If the editor service also used UtilActuator the match is guaranteed.
	 *
	 * @param actuator
	 *            The ontology instance of the actuator you want to get the
	 *            status from.
	 * @param out
	 *            The returned value of the actuator GET service will be placed
	 *            in the URI represented by this String. Look for it there in
	 *            the response.
	 * @return The ServiceRequest that will call the matching GET STATUS service
	 *         of an actuator
	 */
	public static ServiceRequest requestGetOnOff(Actuator actuator, String out) {
		return requestGetOnOff(DeviceService.MY_URI, actuator, out);
	}

	/**
	 * Gives you the typical SET ON service request for actuator services. If
	 * the editor service also used UtilActuator the match is guaranteed.
	 *
	 * @param ontologyURI
	 *            The MY_URI of the class of Service ontology you want to call
	 * @param argIn
	 *            Value representing the input you want to pass as parameter.
	 *            The actuator SET ON service will be called for this specific
	 *            actuator.
	 * @return The ServiceRequest that will call the matching SET ON service of
	 *         an actuator
	 */
	public static ServiceRequest requestSetOn(String ontologyURI, Variable argIn) {
		Request req = new Request((Service) OntologyManagement.getInstance().getResource(ontologyURI, null));
		req.put(Path.at(DeviceService.PROP_CONTROLS), argIn);
		req.put(Path.at(DeviceService.PROP_CONTROLS).to(Actuator.PROP_HAS_VALUE), Arg.change(StatusValue.Activated));
		return req;
	}

	/**
	 * Gives you the typical SET ON service request for actuator services. If
	 * the editor service also used UtilActuator the match is guaranteed.
	 *
	 * @param ontologyURI
	 *            The MY_URI of the class of Service ontology you want to call
	 * @param actuator
	 *            The ontology instance of the actuator you want to set on.
	 * @return The ServiceRequest that will call the matching SET ON service of
	 *         an actuator
	 */
	public static ServiceRequest requestSetOn(String ontologyURI, Actuator actuator) {
		return requestSetOn(ontologyURI, Arg.in(actuator));
	}

	/**
	 * Gives you the typical SET ON service request for actuator services. If
	 * the editor service also used UtilActuator the match is guaranteed.
	 *
	 * @param actuator
	 *            The ontology instance of the actuator you want to set on.
	 * @return The ServiceRequest that will call the matching SET ON service of
	 *         an actuator
	 */
	public static ServiceRequest requestSetOn(Actuator actuator) {
		return requestSetOn(DeviceService.MY_URI, actuator);
	}

	/**
	 * Gives you the typical SET OFF service request for actuator services. If
	 * the editor service also used UtilActuator the match is guaranteed.
	 *
	 * @param ontologyURI
	 *            The MY_URI of the class of Service ontology you want to call
	 * @param argIn
	 *            Value representing the input you want to pass as parameter.
	 *            The actuator SET OFF service will be called for this specific
	 *            actuator.
	 * @return The ServiceRequest that will call the matching SET OFF service of
	 *         an actuator
	 */
	public static ServiceRequest requestSetOff(String ontologyURI, Variable argIn) {
		Request req = new Request((Service) OntologyManagement.getInstance().getResource(ontologyURI, null));
		req.put(Path.at(DeviceService.PROP_CONTROLS), argIn);
		req.put(Path.at(DeviceService.PROP_CONTROLS).to(Actuator.PROP_HAS_VALUE), Arg.change(StatusValue.NotActivated));
		return req;
	}

	/**
	 * Gives you the typical SET OFF service request for actuator services. If
	 * the editor service also used UtilActuator the match is guaranteed.
	 *
	 * @param ontologyURI
	 *            The MY_URI of the class of Service ontology you want to call
	 * @param actuator
	 *            The ontology instance of the actuator you want to set off.
	 * @return The ServiceRequest that will call the matching SET OFF service of
	 *         an actuator
	 */
	public static ServiceRequest requestSetOff(String ontologyURI, Actuator actuator) {
		return requestSetOff(ontologyURI, Arg.in(actuator));
	}

	/**
	 * Gives you the typical SET OFF service request for actuator services. If
	 * the editor service also used UtilActuator the match is guaranteed.
	 *
	 * @param actuator
	 *            The ontology instance of the actuator you want to set off.
	 * @return The ServiceRequest that will call the matching SET OFF service of
	 *         an actuator
	 */
	public static ServiceRequest requestSetOff(Actuator actuator) {
		return requestSetOff(DeviceService.MY_URI, actuator);
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/context/Pattern.java</td>
<td>universAAL Support Utilities API</td>
<td>43</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/context/Pattern.java</td>
<td>universAAL Utilities APIs</td>
<td>43</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class Pattern extends ContextEventPattern {
	/**
	 * Helper error message.
	 */
	private static final String MSG_STR = &quot;---SIMPLE UTILS TIP: You must &quot;
			+ &quot;pass a valid \&quot;MY URI\&quot; of a ManagedIndivdual to this &quot; + &quot;UtilSubscriber constructor, or null.&quot;;
	/**
	 * Helper error message.
	 */
	private static final String MSG_PRED = &quot;---SIMPLE UTILS TIP: You must &quot;
			+ &quot;pass a valid \&quot;URI\&quot; of a Property to this &quot; + &quot;UtilSubscriber constructor, or null.&quot;;
	/**
	 * Helper error message.
	 */
	private static final String MSG_INST = &quot;---SIMPLE UTILS TIP: You must &quot;
			+ &quot;pass a valid ManagedIndivdual or DataType to this &quot; + &quot;UtilSubscriber constructor, or null.&quot;;

	/**
	 * Simple constructor to create a Context Event Pattern with restrictions on
	 * the type of subject, the predicate, and the type of object. Any of these
	 * can be null if no restriction is desired over that concept.
	 *
	 * @param subjTypeURI
	 *            The type URI that the event subject must have. Null for any.
	 * @param predicate
	 *            The exact predicate that the event must equal. Null for any.
	 * @param objTypeURI
	 *            The type URI that the event object must have. Null for any.
	 */
	public Pattern(String subjTypeURI, String predicate, String objTypeURI) {
		super();
		if (subjTypeURI != null) {
			if (Resource.isQualifiedName(subjTypeURI)) {
				this.addRestriction(
						MergedRestriction.getAllValuesRestriction(ContextEvent.PROP_RDF_SUBJECT, subjTypeURI));
			} else {
				System.out.println(MSG_STR);
			}
		}
		if (predicate != null) {
			if (Resource.isQualifiedName(predicate)) {
				this.addRestriction(
						MergedRestriction.getFixedValueRestriction(ContextEvent.PROP_RDF_PREDICATE, predicate));
			} else {
				System.out.println(MSG_PRED);
			}
		}
		if (objTypeURI != null) {
			if (Resource.isQualifiedName(objTypeURI)) {
				this.addRestriction(
						MergedRestriction.getAllValuesRestriction(ContextEvent.PROP_RDF_OBJECT, objTypeURI));
			} else {
				System.out.println(MSG_STR);
			}
		}
	}

	/**
	 * Simple constructor to create a Context Event Pattern with restrictions on
	 * the type of subject, the predicate, and the exact object. Any of these
	 * can be null if no restriction is desired over that concept.
	 *
	 * @param subjTypeURI
	 *            The type URI that the event subject must have. Null for any.
	 * @param predicate
	 *            The exact predicate that the event must equal. Null for any.
	 * @param obj
	 *            The exact instance that the event object must equal. Null for
	 *            any.
	 */
	public Pattern(String subjTypeURI, String predicate, Object obj) {
		super();
		if (subjTypeURI != null) {
			if (Resource.isQualifiedName(subjTypeURI)) {
				this.addRestriction(
						MergedRestriction.getAllValuesRestriction(ContextEvent.PROP_RDF_SUBJECT, subjTypeURI));
			} else {
				System.out.println(MSG_STR);
			}
		}
		if (predicate != null) {
			if (Resource.isQualifiedName(predicate)) {
				this.addRestriction(
						MergedRestriction.getFixedValueRestriction(ContextEvent.PROP_RDF_PREDICATE, predicate));
			} else {
				System.out.println(MSG_PRED);
			}
		}
		if (obj != null) {
			String uri = ManagedIndividual.getTypeURI(obj);
			if (uri != null &amp;&amp; Resource.isQualifiedName(uri)) {
				this.addRestriction(MergedRestriction.getFixedValueRestriction(ContextEvent.PROP_RDF_OBJECT, obj));
			} else {
				System.out.println(MSG_INST);
			}
		}
	}

	/**
	 * Simple constructor to create a Context Event Pattern with restrictions on
	 * the exact subject, the predicate, and the type of object. Any of these
	 * can be null if no restriction is desired over that concept.
	 *
	 * @param subj
	 *            The exact instance that the event subject must equal. Null for
	 *            any.
	 * @param predicate
	 *            The exact predicate that the event must equal. Null for any.
	 * @param objTypeURI
	 *            The type URI that the event object must have. Null for any.
	 */
	public Pattern(ManagedIndividual subj, String predicate, String objTypeURI) {
		super();
		if (subj != null) {
			String uri = ManagedIndividual.getTypeURI(subj);
			if (uri != null &amp;&amp; Resource.isQualifiedName(uri)) {
				this.addRestriction(MergedRestriction.getFixedValueRestriction(ContextEvent.PROP_RDF_SUBJECT, subj));
			} else {
				System.out.println(MSG_INST);
			}
		}
		if (predicate != null) {
			if (Resource.isQualifiedName(predicate)) {
				this.addRestriction(
						MergedRestriction.getFixedValueRestriction(ContextEvent.PROP_RDF_PREDICATE, predicate));
			} else {
				System.out.println(MSG_PRED);
			}
		}
		if (objTypeURI != null) {
			if (Resource.isQualifiedName(objTypeURI)) {
				this.addRestriction(
						MergedRestriction.getAllValuesRestriction(ContextEvent.PROP_RDF_OBJECT, objTypeURI));
			} else {
				System.out.println(MSG_STR);
			}
		}
	}

	/**
	 * Simple constructor to create a Context Event Pattern with restrictions on
	 * the exact subject, the predicate, and the exact object. Any of these can
	 * be null if no restriction is desired over that concept.
	 *
	 * @param subj
	 *            The exact instance that the event subject must equal. Null for
	 *            any.
	 * @param predicate
	 *            The exact predicate that the event must equal. Null for any.
	 * @param obj
	 *            The exact instance that the event object must equal. Null for
	 *            any.
	 */
	public Pattern(ManagedIndividual subj, String predicate, Object obj) {
		super();
		if (subj != null) {
			String uri = ManagedIndividual.getTypeURI(subj);
			if (uri != null &amp;&amp; Resource.isQualifiedName(uri)) {
				this.addRestriction(MergedRestriction.getFixedValueRestriction(ContextEvent.PROP_RDF_SUBJECT, subj));
			} else {
				System.out.println(MSG_INST);
			}
		}
		if (predicate != null) {
			if (Resource.isQualifiedName(predicate)) {
				this.addRestriction(
						MergedRestriction.getFixedValueRestriction(ContextEvent.PROP_RDF_PREDICATE, predicate));
			} else {
				System.out.println(MSG_PRED);
			}
		}
		if (obj != null) {
			String uri = ManagedIndividual.getTypeURI(obj);
			if (uri != null &amp;&amp; Resource.isQualifiedName(uri)) {
				this.addRestriction(MergedRestriction.getFixedValueRestriction(ContextEvent.PROP_RDF_OBJECT, obj));
			} else {
				System.out.println(MSG_INST);
			}
		}
	}
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/UAAL.java</td>
<td>universAAL Support Utilities API</td>
<td>91</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/UAAL.java</td>
<td>universAAL Utilities APIs</td>
<td>91</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class UAAL {

	/**
	 * The single Context Publisher universAAL wrapper class used by this class to
	 * publish all Context Events.
	 */
	private ContextPublisher publisher;
	/**
	 * A list of all Context Subscriber universAAL wrapper classes used by this class
	 * to receive subscribed Context Events. The reason for having a list of
	 * subscribers is that it simplifies the association between the subscribed
	 * pattern and the handling to perform associated to it.
	 */
	private ArrayList&lt;WrapperC&gt; subscribers;
	/**
	 * The single Service Caller universAAL wrapper class used by this class to call
	 * all Service Requests.
	 */
	private ServiceCaller caller;
	/**
	 * A list of all Service Callee universAAL wrapper classes used by this class to
	 * handle calls to provided Service Profiles. The reason for having a list
	 * of callees is that it simplifies the association between the provided
	 * profile and the handling to perform associated to it.
	 */
	private ArrayList&lt;WrapperS&gt; callees;
	/**
	 * The single UI Caller universAAL wrapper class used by this class to send all UI
	 * Requests.
	 */
	private WrapperUI requester;
	/**
	 * The universAAL Module Context.
	 */
	private ModuleContext context;

	/**
	 * This constructor just assigns the Module Context: the rest of resources
	 * used by this class are not initialized. They will be automatically
	 * initialized as they are needed when you use the universAAL features methods of
	 * the class, so you don't have to do anything else. All resources will be
	 * maintained until you call &lt;code&gt;terminate()&lt;/code&gt;.
	 * &lt;p&gt;
	 * Although it is possible to have as many instances of this class as
	 * desired (no restrictions are set about it), it is recommended to maintain
	 * just a single(ton) instance of it, and make it accessible to the rest of
	 * your application code.
	 *
	 * @param context
	 *            The universAAL Module Context.
	 */
	public UAAL(ModuleContext context) {
		this.context = context;
	}

	/**
	 * Sends a Context Event.
	 * &lt;p&gt;
	 * universAAL helper automatically creates its own internal Context Publisher if
	 * this is the first time the method is called. If the passed event contains
	 * ContextProvider information, it is used to instantiate the Publisher.
	 * Otherwise the missing information is automatically generated: The
	 * Publisher is described as either a Gauge or a Controller depending on if
	 * you are providing Services (you called method &lt;code&gt;provideS()&lt;/code&gt;
	 * before). The URI of the Provider is then set to
	 * &lt;i&gt;http://ontology.universAAL.org/SimpleUAAL
	 * .owl#ContextEventsProvider&lt;/i&gt; and it cannot be changed. Currently, the
	 * pattern that describes the provided events of this provider is empty,
	 * which means it can publish any type of event. Notice this Provider info
	 * is set ONLY THE FIRST TIME and cannot be changed by later calls.
	 *
	 * @param e
	 *            The Context Event to send.
	 */
	public void sendC(ContextEvent e) {
		// TODO: Handle multiple provided patterns
		ContextProvider cp = e.getProvider();
		// Because we are building the provider here, it will not be the same
		// object
		// This would fail the match in bus and not send the event. Remove it so
		// it is set by the bus:
		if (cp != null)
			e.changeProperty(ContextEvent.PROP_CONTEXT_PROVIDER, null);
		// This only happens the first time:
		if (publisher == null) {
			// Yeah lots of ifs and returns, ugly but easy to read
			if (cp != null) {
				ContextProviderType cpt = cp.getProviderType();
				if (cpt != null) {
					ContextEventPattern[] cpe = cp.getProvidedEvents();
					if (cpe != null) {
						publisher = new UtilPublisher(context, cp.getURI(), cpt, cpe);
						publisher.publish(e);
						return;
					}
					publisher = new UtilPublisher(context, cp.getURI(), cpt, (String) null, null, null);
					publisher.publish(e);
					return;
				}
				publisher = new UtilPublisher(context, cp.getURI(), (callees != null &amp;&amp; !callees.isEmpty())
						? ContextProviderType.controller : ContextProviderType.gauge, (String) null, null, null);
				publisher.publish(e);
				return;
			}
			publisher = new UtilPublisher(context,
					&quot;http://ontology.universAAL.org/SimpleUAAL.owl#ContextEventsProvider&quot;,
					(callees != null &amp;&amp; !callees.isEmpty()) ? ContextProviderType.controller
							: ContextProviderType.gauge,
					(String) null, null, null);

		}
		publisher.publish(e);
	}

	/**
	 * Calls a Service with a Service Request.
	 * &lt;p&gt;
	 * universAAL helper automatically creates its own internal Default Service Caller
	 * if this is the first time the method is called. The call to the service
	 * is synchronous: this method returns the response of the call straight
	 * from Service Bus. You will have to deal with it.
	 * &lt;p&gt;
	 * Remember that the simplified API in this library (
	 * &lt;code&gt;org.universAAL.support.utils.service&lt;/code&gt; packages) can assist
	 * you in creating Service Requests and handling Service Responses.
	 *
	 * @param r
	 *            The Service Request describing the Service to call.
	 * @return The Service Response to the call returned by the Service Bus.
	 *
	 * @see org.universAAL.support.utils.service.low.Request
	 */
	public ServiceResponse callS(ServiceRequest r) {
		if (caller == null) {
			caller = new DefaultServiceCaller(context);
		}
		return caller.call(r);
	}

	/**
	 * Requests User Interaction and specifies how the response would be
	 * handled.
	 * &lt;p&gt;
	 * universAAL helper automatically creates its own internal UI Caller if this is
	 * the first time the method is called. An implementation of
	 * {@link IUIListener} must be passed that will handle the response to the
	 * UI Request that is being sent. The response contains the user input to
	 * the forms described in the UI Request, so the listener must be ready to
	 * work with the fields, controls, submits and identifiers used in the
	 * request. There can only be a single listener associated to the UI Caller
	 * at a time, which means this method cannot be called again with a new
	 * listener until the previous response has been received and processed by
	 * the old listener. Another solution is using always the same instance of
	 * the listener, which should then be ready to handle any possible UI
	 * response to your application.
	 * &lt;p&gt;
	 * Remember that the simplified API in this library (
	 * &lt;code&gt;org.universAAL.support.utils.ui&lt;/code&gt; packages) can assist you in
	 * creating UI Requests.
	 *
	 * @param ui
	 *            The UI request with the output to display to the user.
	 * @param l
	 *            The listener that will handle the response to that UI request.
	 * @see org.universAAL.support.utils.ui.low.Dialog
	 * @see org.universAAL.support.utils.ui.low.Message
	 * @see org.universAAL.support.utils.ui.low.SubDialog
	 */
	public void requestUI(UIRequest ui, IUIListener l) {
		if (requester == null) {
			requester = new WrapperUI(context);
		}
		requester.setListener(l);
		requester.sendUIRequest(ui);
	}

	/**
	 * Subscribes for Context Events and specifies how the events would be
	 * handled.
	 * &lt;p&gt;
	 * universAAL helper automatically creates a new own internal Context Subscriber
	 * each time this method is called. An implementation of {@link ICListener}
	 * must be passed that will handle the reception of an event that matches
	 * the passed patterns. The listener is associated to the patterns: All
	 * events that match the patterns are received by the listener (regardless
	 * of any other calls to this method). The listener remains active and
	 * associated to the patterns until &lt;code&gt;terminate()&lt;/code&gt; is called.
	 * Since every call to this method creates a new subscriber, you should be
	 * careful with how many times you call this method. Usually, a limited
	 * number of subscriptions is needed. Remember that you can combine
	 * different patterns to be handled by a single listener.
	 * &lt;p&gt;
	 * Remember that the simplified API in this library (
	 * &lt;code&gt;org.universAAL.support.utils.context&lt;/code&gt; packages) can assist
	 * you in creating Context Event Patterns.
	 *
	 * @param p
	 *            An array of Context Event Patterns describing the Context
	 *            Events that will be handled by the listener.
	 * @param l
	 *            The listener that will handle the received event that matches
	 *            the patterns.
	 * @see org.universAAL.support.utils.context.Pattern
	 */
	public void subscribeC(ContextEventPattern[] p, ICListener l) {
		if (subscribers == null) {
			subscribers = new ArrayList&lt;WrapperC&gt;(5);
		}
		subscribers.add(new WrapperC(context, p, l));
	}

	/**
	 * Registers Service Profiles and specifies how the calls to these profiles
	 * would be handled.
	 * &lt;p&gt;
	 * universAAL helper automatically creates a new own internal Service Callee each
	 * time this method is called. An implementation of {@link ISListener} must
	 * be passed that will handle the call request that matches the provided
	 * profiles. The listener is associated to the profiles: All call requests
	 * that match the profiles are received by the listener (regardless of any
	 * other calls to this method). The listener remains active and associated
	 * to the profiles until &lt;code&gt;terminate()&lt;/code&gt; is called. Since every
	 * call to this method creates a new callee, you should be careful with how
	 * many times you call this method. Usually, a limited number of callees is
	 * needed.
	 * &lt;p&gt;
	 * Remember that the simplified API in this library (
	 * &lt;code&gt;org.universAAL.support.utils.service&lt;/code&gt; packages) can assist
	 * you in creating Service Profiles.
	 *
	 * @param p
	 *            An array of Service Profiles describing the provided services
	 *            that will be handled by the listener.
	 * @param l
	 *            The listener that will handle the received call request that
	 *            matches the provided service profiles.
	 * @see org.universAAL.support.utils.service.low.Profile
	 */
	public void provideS(ServiceProfile[] p, ISListener l) {
		if (callees == null) {
			callees = new ArrayList&lt;WrapperS&gt;(5);
		}
		callees.add(new WrapperS(context, p, l));
	}

	/**
	 * Closes all universAAL wrapper classes created by this universAAL helper until now (by
	 * calling their &lt;code&gt;.close()&lt;/code&gt; method) and eliminates them. The
	 * reference to the Module Context is maintained, however. This allows to
	 * perform new calls to the universAAL features methods, which will create new
	 * universAAL wrappers in the helper.
	 */
	public void terminate() {
		if (publisher != null) {
			publisher.close();
			publisher = null;
		}
		if (caller != null) {
			caller.close();
			caller = null;
		}
		if (requester != null) {
			requester.close();
			requester = null;
		}

		if (subscribers != null) {
			Iterator&lt;WrapperC&gt; iter = subscribers.iterator();
			while (iter.hasNext()) {
				((WrapperC) iter.next()).close();
			}
			subscribers.clear();
			subscribers = null;
		}

		if (callees != null) {
			Iterator&lt;WrapperS&gt; iter = callees.iterator();
			while (iter.hasNext()) {
				((WrapperS) iter.next()).close();
			}
			callees.clear();
			callees = null;
		}
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/service/mid/UtilSensor.java</td>
<td>universAAL Support Utilities API</td>
<td>51</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/service/mid/UtilSensor.java</td>
<td>universAAL Utilities APIs</td>
<td>51</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class UtilSensor {
	/**
	 * Service suffix.
	 */
	public static final String SERVICE_GET_ON_OFF = &quot;servSensorGet&quot;;
	/**
	 * Argument suffix.
	 */
	public static final String OUT_GET_ON_OFF = &quot;outputSensorGet&quot;;
	/**
	 * Argument suffix.
	 */
	public static final String IN_DEVICE = &quot;inputSensorAll&quot;;

	/**
	 * Gives you the typical service profile of an on/off sensor service: Get
	 * status. When handling requests in your Callee, you can use the references
	 * to services and arguments URIs prepending &lt;code&gt;namespace&lt;/code&gt; to
	 * UtilSensor constants.
	 * &lt;p&gt;
	 * BE CAREFUL: This will only work with sensors that have StatusValue as
	 * HAS_VALUE property. Others, like DimmerSensor, will throw an exception.
	 * &lt;p&gt;
	 * Example:
	 * &lt;p&gt;
	 * &lt;code&gt;
	 * new SCallee(context, getServiceProfiles(&quot;http://ontology.universAAL.org/OvenServer.owl#&quot;, CarpetSensor.MY_URI, myCarpetSensor))
	 * &lt;/code&gt;
	 * &lt;p&gt;
	 *
	 * @param namespace
	 *            The namespace of your server, ending with the character #. You
	 *            can optionally add some prefix after the # if you use
	 *            UtilSensor more than once in the same Callee.
	 * @param ontologyURI
	 *            The MY_URI of the class of DeviceService ontology you are
	 *            going to implement. It MUST be a subclass of DeviceService.
	 * @param sensor
	 *            The ontology instance of the sensor you are controlling. The
	 *            more properties it has set, the better.
	 * @return An array with the 1 typical service profiles
	 * @throws InvalidOntologyUtilException
	 *             when an sensor is passed that is does not have StatusValue as
	 *             type restriction of its HAS_VALUE property.
	 */
	public static ServiceProfile[] getServiceProfiles(String namespace, String ontologyURI, Sensor sensor)
			throws InvalidOntologyUtilException {
		try {
			if (sensor.getOntClassInfo().getRestrictionsOnProp(Sensor.PROP_HAS_VALUE).getPropTypeURI()
					.equals(StatusValue.MY_URI)) {
				throw new InvalidOntologyUtilException(&quot;The Actuator ontology passed as parameter &quot;
						+ &quot;is not an on/off Actuator: its HAS_VALUE&quot; + &quot; property must be of type StatusValue&quot;);
			}
		} catch (NullPointerException e) {
			throw new InvalidOntologyUtilException(&quot;The Actuator ontology passed as parameter&quot;
					+ &quot; misses some restriction on its HAS_VALUE&quot; + &quot; property. It must be of type StatusValue&quot;);
		}
		ServiceProfile[] profiles = new ServiceProfile[1];

		PropertyPath ppath = new PropertyPath(null, true,
				new String[] { DeviceService.PROP_CONTROLS, Sensor.PROP_HAS_VALUE });

		ProcessInput input = new ProcessInput(namespace + IN_DEVICE);
		input.setParameterType(sensor.getClassURI());
		input.setCardinality(1, 0);

		MergedRestriction r = MergedRestriction.getFixedValueRestriction(DeviceService.PROP_CONTROLS, sensor);

		Service getOnOff = (Service) OntologyManagement.getInstance().getResource(ontologyURI,
				namespace + SERVICE_GET_ON_OFF);
		profiles[0] = getOnOff.getProfile();
		ProcessOutput output = new ProcessOutput(namespace + OUT_GET_ON_OFF);
		output.setCardinality(1, 1);
		profiles[0].addOutput(output);
		profiles[0].addSimpleOutputBinding(output, ppath.getThePath());
		profiles[0].addInput(input);
		profiles[0].getTheService().addInstanceLevelRestriction(r, new String[] { DeviceService.PROP_CONTROLS });

		return profiles;
	}

	/**
	 * Gives you the typical service profile of an on/off sensor service: Get
	 * status. When handling requests in your Callee, you can use the references
	 * to services and arguments URIs prepending &lt;code&gt;namespace&lt;/code&gt; to
	 * UtilSensor constants.
	 * &lt;p&gt;
	 * BE CAREFUL: This will only work with sensors that have StatusValue as
	 * HAS_VALUE property. Others, like DimmerSensor, will throw an exception.
	 *
	 * @param namespace
	 *            The namespace of your server, ending with the character #. You
	 *            can optionally add some prefix after the # if you use
	 *            UtilSensor more than once in the same Callee.
	 * @param sensor
	 *            The ontology instance of the sensor you are controlling. The
	 *            more properties it has set, the better.
	 * @return An array with the 1 typical service profiles
	 * @throws InvalidOntologyUtilException
	 *             when an sensor is passed that is does not have StatusValue as
	 *             type restriction of its HAS_VALUE property.
	 */
	public static ServiceProfile[] getServiceProfiles(String namespace, Sensor sensor)
			throws InvalidOntologyUtilException {
		return getServiceProfiles(namespace, DeviceService.MY_URI, sensor);
	}

	/**
	 * Gives you the typical GET STATUS service request for sensor services. If
	 * the editor service also used UtilSensor the match is guaranteed.
	 *
	 * @param ontologyURI
	 *            The MY_URI of the class of Service ontology you want to call
	 * @param argIn
	 *            Value representing the input you want to pass as parameter.
	 *            The sensor GET service will be called for this specific
	 *            actuator.
	 * @param argOut
	 *            The returned value of the sensor GET service will be placed in
	 *            the URI represented by this Output. Look for it there in the
	 *            response.
	 * @return The ServiceRequest that will call the matching GET STATUS service
	 *         of an sensor
	 */
	public static ServiceRequest requestGetOnOff(String ontologyURI, Variable argIn, Output argOut) {
		Request req = new Request((Service) OntologyManagement.getInstance().getResource(ontologyURI, null));
		req.put(Path.at(DeviceService.PROP_CONTROLS), argIn);
		req.put(Path.at(DeviceService.PROP_CONTROLS).to(Sensor.PROP_HAS_VALUE), argOut);
		return req;
	}

	/**
	 * Gives you the typical GET STATUS service request for sensor services. If
	 * the editor service also used UtilSensor the match is guaranteed.
	 *
	 * @param ontologyURI
	 *            The MY_URI of the class of Service ontology you want to call
	 * @param in
	 *            Object representing the input you want to pass as parameter.
	 *            The sensor GET service will be called for this specific
	 *            actuator.
	 * @param out
	 *            The returned value of the sensor GET service will be placed in
	 *            this URI. Look for it there in the response.
	 * @return The ServiceRequest that will call the matching GET STATUS service
	 *         of an sensor
	 */
	public static ServiceRequest requestGetOnOff(String ontologyURI, Object in, String out) {
		Request req = new Request((Service) OntologyManagement.getInstance().getResource(ontologyURI, null));
		req.put(Path.at(DeviceService.PROP_CONTROLS), Arg.in(in));
		req.put(Path.at(DeviceService.PROP_CONTROLS).to(Sensor.PROP_HAS_VALUE), Arg.out(out));
		return req;
	}

	/**
	 * Gives you the typical GET STATUS service request for sensor services. If
	 * the editor service also used UtilSensor the match is guaranteed.
	 *
	 * @param ontologyURI
	 *            The MY_URI of the class of Service ontology you want to call
	 * @param sensor
	 *            The ontology instance of the sensor you want to get the status
	 *            from.
	 * @param argOut
	 *            The returned value of the sensor GET service will be placed in
	 *            the URI represented by this Output. Look for it there in the
	 *            response.
	 * @return The ServiceRequest that will call the matching GET STATUS service
	 *         of an sensor
	 */
	public static ServiceRequest requestGetOnOff(String ontologyURI, Sensor sensor, Output argOut) {
		return requestGetOnOff(ontologyURI, Arg.in(sensor), argOut);
	}

	/**
	 * Gives you the typical GET STATUS service request for sensor services. If
	 * the editor service also used UtilSensor the match is guaranteed.
	 *
	 * @param ontologyURI
	 *            The MY_URI of the class of Service ontology you want to call
	 * @param sensor
	 *            The ontology instance of the sensor you want to get the status
	 *            from.
	 * @param out
	 *            The returned value of the sensor GET service will be placed in
	 *            the URI represented by this String. Look for it there in the
	 *            response.
	 * @return The ServiceRequest that will call the matching GET STATUS service
	 *         of an sensor
	 */
	public static ServiceRequest requestGetOnOff(String ontologyURI, Sensor sensor, String out) {
		return requestGetOnOff(ontologyURI, Arg.in(sensor), Arg.out(out));
	}

	/**
	 * Gives you the typical GET STATUS service request for sensor services. If
	 * the editor service also used UtilSensor the match is guaranteed.
	 *
	 * @param sensor
	 *            The ontology instance of the sensor you want to get the status
	 *            from.
	 * @param argOut
	 *            The returned value of the sensor GET service will be placed in
	 *            the URI represented by this Output. Look for it there in the
	 *            response.
	 * @return The ServiceRequest that will call the matching GET STATUS service
	 *         of an sensor
	 */
	public static ServiceRequest requestGetOnOff(Sensor sensor, Output argOut) {
		return requestGetOnOff(DeviceService.MY_URI, sensor, argOut);
	}

	/**
	 * Gives you the typical GET STATUS service request for sensor services. If
	 * the editor service also used UtilSensor the match is guaranteed.
	 *
	 * @param sensor
	 *            The ontology instance of the sensor you want to get the status
	 *            from.
	 * @param out
	 *            The returned value of the sensor GET service will be placed in
	 *            the URI represented by this String. Look for it there in the
	 *            response.
	 * @return The ServiceRequest that will call the matching GET STATUS service
	 *         of an sensor
	 */
	public static ServiceRequest requestGetOnOff(Sensor sensor, String out) {
		return requestGetOnOff(DeviceService.MY_URI, sensor, out);
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/ui/mid/UtilUICaller.java</td>
<td>universAAL Support Utilities API</td>
<td>59</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/ui/mid/UtilUICaller.java</td>
<td>universAAL Utilities APIs</td>
<td>59</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public abstract class UtilUICaller extends UICaller {

	/**
	 * The root directory of the runtime configuration.
	 */
	public static final String CONF_ROOT_DIR = &quot;bundles.configuration.location&quot;;

	/**
	 * Associated Service Callee.
	 */
	private UIcallee callee;

	/**
	 * Constructor to create a Simple UI Caller that handles first call
	 * interaction and addition to Main Menu.
	 *
	 * @param context
	 *            The universAAL module context.
	 * @param namespace
	 *            Namespace to be used by the UI Caller references (only for
	 *            initial UI request).
	 * @param url
	 *            The URL of your company, for identificative purposes only.
	 * @param title
	 *            Name of the application, which will appear in the Main Menu
	 *            submit.
	 */
	protected UtilUICaller(ModuleContext context, String namespace, String url, String title) {
		super(context);
		callee = new UIcallee(context, namespace, url, title, this);
		File dm = new File(new File(System.getProperty(CONF_ROOT_DIR, System.getProperty(&quot;user.dir&quot;))), &quot;ui.dm&quot;);
		File dmmob = new File(new File(System.getProperty(CONF_ROOT_DIR, System.getProperty(&quot;user.dir&quot;))),
				&quot;ui.dm.mobile&quot;);
		try {
			if (dm.exists()) {
				populate(dm, namespace, url, title);
			}
			if (dmmob.exists()) {
				populate(dmmob, namespace, url, title);
			}
		} catch (IOException e) {
			e.printStackTrace();
		}
	}

	/**
	 * Scans all Dialog Manager Main Menu files and inserts the application
	 * button.
	 *
	 * @param dm
	 *            Dialog Manger configuration folder.
	 * @param namespace
	 *            Namespace to be used by the UI Caller references (only for
	 *            initial UI request).
	 * @param url
	 *            The URL of your company, for identificative purposes only.
	 * @param title
	 *            Name of the application, which will appear in the Main Menu
	 *            submit.
	 * @throws IOException
	 *             If there was any problem with the files.
	 */
	private void populate(File dm, String namespace, String url, String title) throws IOException {
		File[] files = dm.listFiles(new FilenameFilter() {
			public boolean accept(File dir, String name) {
				return name.toLowerCase().startsWith(&quot;main_menu&quot;);
			}
		});
		for (int i = 0; i &lt; files.length; i++) {
			BufferedReader br = new BufferedReader(new FileReader(files[i]));
			String readline = br.readLine();
			boolean found = false;
			while (readline != null) {
				if (readline.contains(namespace + &quot;UIService&quot;)) {
					readline = null;
					found = true;
				} else {
					readline = br.readLine();
				}
			}
			if (!found) {
				BufferedWriter bw = new BufferedWriter(new FileWriter(files[i], true));
				bw.newLine();
				bw.write(&quot;/&quot; + title + &quot;|&quot; + url + &quot;|&quot; + namespace + &quot;UIService&quot;);
				bw.newLine();
				bw.close();
			}
			br.close();
		}
	}

	/**
	 * This method is called whenever the user selects your application submit
	 * from the Main Menu. You should initiate the interaction with the user
	 * here by publishing some kind of Dialog.
	 *
	 * @param resource
	 *            The User which initiated the interaction. May be an instance
	 *            of User, AssistedPerson or Caregiver.
	 */
	public abstract void executeStartUI(Resource resource);

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.universAAL.support.utils.ui.UICaller#communicationChannelBroken()
	 */
	@Override
	public void communicationChannelBroken() {
		callee.close();
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see org.universAAL.middleware.ui.UICaller#close()
	 */
	@Override
	public void close() {
		callee.close();
		super.close();
	}

	/**
	 * Internal Service Callee that handles the call to the &quot;start UI&quot; service
	 * from the Dialog Manager when a user selects the application Submit form
	 * the Main Menu.
	 *
	 * @author alfiva
	 *
	 */
	private class UIcallee extends ServiceCallee {

		/**
		 * Placeholder for composed URI for start service.
		 */
		private String startUI = &quot;&quot;;
		/**
		 * Reference to UI caller.
		 */
		private UtilUICaller ui;

		/**
		 * Constructs a Service Callee for the &quot;start UI&quot; service.
		 *
		 * @param context
		 *            The universAAL module context.
		 * @param namespace
		 *            Namespace to be used by the UI Caller references (only for
		 *            initial UI request).
		 * @param url
		 *            The URL of your company, for identificative purposes only.
		 * @param desc
		 *            Name of the application, which will appear in the Main
		 *            Menu submit.
		 * @param uicaller
		 *            The Simple UI Caller that requires this service.
		 */
		protected UIcallee(ModuleContext context, String namespace, String url, String desc, UtilUICaller uicaller) {
			super(context, new ServiceProfile[] { InitialServiceDialog
					.createInitialDialogProfile(namespace + &quot;UIService&quot;, url, desc, namespace + &quot;startUI&quot;) });
			startUI = namespace + &quot;startUI&quot;;
			ui = uicaller;
		}

		/*
		 * (non-Javadoc)
		 *
		 * @see org.universAAL.middleware.service.ServiceCallee#
		 * communicationChannelBroken()
		 */
		@Override
		public void communicationChannelBroken() {
			// Nothing
		}

		/*
		 * (non-Javadoc)
		 *
		 * @see org.universAAL.middleware.service.ServiceCallee#handleCall(org.
		 * universAAL .middleware.service.ServiceCall)
		 */
		@Override
		public ServiceResponse handleCall(ServiceCall call) {
			if (call != null) {
				String operation = call.getProcessURI();
				if (operation != null &amp;&amp; operation.startsWith(startUI)) {
					ui.executeStartUI(call.getInvolvedUser());
					ServiceResponse sr = new ServiceResponse(CallStatus.succeeded);
					return sr;
				}
			}
			return null;
		}

	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/service/low/Request.java</td>
<td>universAAL Support Utilities API</td>
<td>63</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/service/low/Request.java</td>
<td>universAAL Utilities APIs</td>
<td>63</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class Request extends ServiceRequest {

	/**
	 * Default namespace.
	 */
	public static final String MY_NAMESPACE = &quot;http://org.universAAL.ontology/SimpleUtils.owl#&quot;;

	/**
	 * Use this helper class to create a ServiceRequest that is easy to use. You
	 * can use this Request also as you could use a normal ServiceRequest.
	 * &lt;p/&gt;
	 * Example: &lt;code&gt;
	 * Request req=new Request(new Lighting(null));&lt;/code&gt;
	 *
	 * @param requestedServiceRoot
	 *            An instance of the Service class that you want to call,
	 *            created with null URI.
	 */
	public Request(Service requestedServiceRoot) {
		super(requestedServiceRoot, null);
	}

	/**
	 * Use this helper method to declare an argument over a Request, specifying
	 * that the requested service must have, in the given branch of properties,
	 * an instance of the &lt;b&gt;same type&lt;/b&gt; expressed with Typematch argument.
	 * &lt;p/&gt;
	 * Example: &lt;code&gt;
	 * req.put(new String[]{Lighting.PROP_CONTROLS,LightSource.PROP_HAS_TYPE}, new Typematch(ElectricLight.MY_URI));
	 * &lt;/code&gt;
	 *
	 * @param branch
	 *            The path of properties from the Service root class to the
	 *            value to be restricted
	 * @param leaf
	 *            The Typematch describing the type of instance expected at the
	 *            end of the branch
	 */
	public void put(String[] branch, Typematch leaf) {
		this.addTypeFilter(branch, leaf.getURI());
	}

	/**
	 * Equivalent to put(String[] branch, Typematch leaf).
	 *
	 * @param branch
	 *            The path of properties from the Service root class to the
	 *            value to be restricted
	 * @param leaf
	 *            The Typematch describing the type of instance expected at the
	 *            end of the branch
	 */
	public void put(Path branch, Typematch leaf) {
		put(branch.path, leaf);
	}

	/**
	 * Use this helper method to declare an argument over a Request, specifying
	 * that the requested service will receive as &lt;b&gt;variable input&lt;/b&gt;, in the
	 * given branch of properties, &lt;b&gt;the instance&lt;/b&gt; expressed with Variable
	 * argument.
	 * &lt;p/&gt;
	 * Example: &lt;code&gt;
	 * req.put(new String[]{Lighting.PROP_CONTROLS}, new Variable(new LightSource(exactURI)));
	 * &lt;/code&gt;
	 *
	 * @param branch
	 *            The path of properties from the Service root class to the
	 *            value to be received as input by the service
	 * @param leaf
	 *            The Variable describing the value that you want to pass as
	 *            variable input to the service
	 */
	public void put(String[] branch, Variable leaf) {
		this.addValueFilter(branch, leaf.getObject());
	}

	/**
	 * Equivalent to put(Path branch, Variable leaf).
	 *
	 * @param branch
	 *            The path of properties from the Service root class to the
	 *            value to be received as input by the service
	 * @param leaf
	 *            The Variable describing the value that you want to pass as
	 *            variable input to the service
	 */
	public void put(Path branch, Variable leaf) {
		put(branch.path, leaf);
	}

	/**
	 * Use this helper method to declare an argument over a Request, specifying
	 * that &lt;b&gt;you want the kind of output&lt;/b&gt; specified by the given branch of
	 * properties, and you want it to be put in the ServiceResponse &lt;b&gt;under the
	 * ID&lt;/b&gt; specified with the Output argument.
	 * &lt;p/&gt;
	 * Example: &lt;code&gt;
	 * req.put(new String[]{Lighting.PROP_CONTROLS}, new Output(&quot;http://ontology.igd.fhg.de/LightingConsumer.owl#listOfLamps&quot;));
	 * &lt;/code&gt;
	 *
	 * @param branch
	 *            The path of properties from the Service root class to the
	 *            output that you want
	 * @param leaf
	 *            The Output describing the URI (the ID) that you will use when
	 *            dealing with the ServiceResponse
	 */
	public void put(String[] branch, Output leaf) {
		this.addRequiredOutput(leaf.getURI(), branch);
	}

	/**
	 * Equivalent to put(String[] branch, Output leaf).
	 *
	 * @param branch
	 *            The path of properties from the Service root class to the
	 *            output that you want
	 * @param leaf
	 *            The Output describing the URI (the ID) that you will use when
	 *            dealing with the ServiceResponse
	 */
	public void put(Path branch, Output leaf) {
		put(branch.path, leaf);
	}

	/**
	 * Use this helper method to declare an argument over a Request, specifying
	 * that you want to &lt;b&gt;add&lt;/b&gt;, in the given branch of properties, &lt;b&gt;the
	 * value&lt;/b&gt; instance expressed with Add argument.
	 * &lt;p/&gt;
	 * Example: &lt;code&gt;
	 * req.put(new String[]{Lighting.PROP_CONTROLS}, new Add(new LightSource(addURI)));
	 * &lt;/code&gt;
	 *
	 * @param branch
	 *            The path of properties from the Service root class to the
	 *            value to be added
	 * @param leaf
	 *            The Add describing the instance to be added at the end of the
	 *            branch
	 */
	public void put(String[] branch, Add leaf) {
		this.addAddEffect(branch, leaf.getObject());
	}

	/**
	 * Equivalent to put(String[] branch, Add leaf).
	 *
	 * @param branch
	 *            The path of properties from the Service root class to the
	 *            value to be added
	 * @param leaf
	 *            The Add describing the instance to be added at the end of the
	 *            branch
	 */
	public void put(Path branch, Add leaf) {
		put(branch.path, leaf);
	}

	/**
	 * Use this helper method to declare an argument over a Request, specifying
	 * that you want to &lt;b&gt;remove&lt;/b&gt;, from the given branch of properties,
	 * &lt;b&gt;the value&lt;/b&gt; instance expressed with Remove argument.
	 * &lt;p/&gt;
	 * Example: &lt;code&gt;
	 * req.put(new String[]{Lighting.PROP_CONTROLS}, new Remove(new LightSource(quitURI)));
	 * &lt;/code&gt;
	 *
	 * @param branch
	 *            The path of properties from the Service root class to the
	 *            value to be removed
	 * @param leaf
	 *            The Remove describing the instance to be removed at the end of
	 *            the branch
	 */
	public void put(String[] branch, Remove leaf) {
		MergedRestriction r1 = MergedRestriction.getFixedValueRestriction(branch[branch.length - 1], leaf.getObject());
		this.getRequestedService().addInstanceLevelRestriction(r1, branch);
		this.addRemoveEffect(branch);
	}

	/**
	 * Equivalent to put(String[] branch, Remove leaf).
	 *
	 * @param branch
	 *            The path of properties from the Service root class to the
	 *            value to be removed
	 * @param leaf
	 *            The Remove describing the instance to be removed at the end of
	 *            the branch
	 */
	public void put(Path branch, Remove leaf) {
		put(branch.path, leaf);
	}

	/**
	 * Use this helper method to declare an argument over a Request, specifying
	 * that you want to &lt;b&gt;change&lt;/b&gt;, at the given branch of properties, an old
	 * value with &lt;b&gt;a new one&lt;/b&gt;, an instance expressed with Change argument.
	 * &lt;p/&gt;
	 * Example: &lt;code&gt;
	 * req.put(new String[]{Lighting.PROP_CONTROLS,LightSource.PROP_SOURCE_BRIGHTNESS }, new Change(new Integer(0)));
	 * &lt;/code&gt;
	 *
	 * @param branch
	 *            The path of properties from the Service root class to the
	 *            value to be changed
	 * @param leaf
	 *            The Change describing the new instance to be put at the end of
	 *            the branch
	 */
	public void put(String[] branch, Change leaf) {
		this.addChangeEffect(branch, leaf.getObject());
	}

	/**
	 * Equivalent to put(String[] branch, Change leaf).
	 *
	 * @param branch
	 *            The path of properties from the Service root class to the
	 *            value to be changed
	 * @param leaf
	 *            The Change describing the new instance to be put at the end of
	 *            the branch
	 */
	public void put(Path branch, Change leaf) {
		put(branch.path, leaf);
	}

	/**
	 * Equivalent to recoverOutputs(ServiceResponse sr, String outputURI).
	 *
	 * @param sr
	 *            The ServiceResponse returned by the .call method
	 * @param output
	 *            The Output you used when building the request
	 * @return An array of Objects that contain all the returned values stored
	 *         at the given Output URI (the ID). You will have to cast them to
	 *         the appropriate class yourself, which you know in advance, as you
	 *         have built the request... Returns &lt;code&gt;null&lt;/code&gt; in all other
	 *         cases (Service errors, no outputs,...)
	 */
	public static Object[] recoverOutputs(ServiceResponse sr, Output output) {
		return recoverOutputs(sr, output.getURI());
	}

	/**
	 * Use this helper method when you have called a ServiceRequest (or a
	 * Request) and you want to get an array containing all the outputs
	 * returned.
	 * &lt;p/&gt;
	 *
	 * @param sr
	 *            The ServiceResponse returned by the .call method
	 * @param outputURI
	 *            The URI (the ID) you used to refer to the output when building
	 *            the request
	 * @return An array of Objects that contain all the returned values stored
	 *         at the given Output URI (the ID). You will have to cast them to
	 *         the appropriate class yourself, which you know in advance, as you
	 *         have built the request... Returns &lt;code&gt;null&lt;/code&gt; in all other
	 *         cases (Service errors, no outputs,...)
	 */
	public static Object[] recoverOutputs(ServiceResponse sr, String outputURI) {
		if (sr.getCallStatus() == CallStatus.succeeded) {
			List outs = sr.getOutput(outputURI, true);
			if (outs == null) {
				System.out.println(&quot;---SIMPLE UTILS TIP: No outputs in the &quot; + &quot;response. Review your requests.&quot;);
			} else if (outs.size() == 0) {
				System.out.println(
						&quot;---SIMPLE UTILS TIP: No outputs with this URI&quot; + &quot; in the response. Review your requests.&quot;);
			} else {
				Object[] values = (Object[]) outs.toArray(new Object[outs.size()]);
				return values;
			}
		} else {
			System.out.println(
					&quot;---SIMPLE UTILS TIP: Service call failed: &quot; + sr.getCallStatus() + &quot;. Review your requests.&quot;);
		}
		return null;
	}

	/**
	 * I have to put this because of all service refactoring stuff.
	 *
	 * @return Nothing, null.
	 */
	protected Hashtable getInput() {
		return null;
	}
}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/service/top/UtilEditorCallee.java</td>
<td>universAAL Support Utilities API</td>
<td>44</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/service/top/UtilEditorCallee.java</td>
<td>universAAL Utilities APIs</td>
<td>44</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public abstract class UtilEditorCallee extends ServiceCallee {

	/**
	 * Namespace for auxiliary URIs used in this class.
	 */
	private String calleeNamespace;

	/**
	 * Default error response when an input parameter does not match.
	 */
	private static final ServiceResponse ERROR_INPUT = new ServiceResponse(CallStatus.serviceSpecificFailure);

	/**
	 * Default constructor of the class. Takes the same parameters needed by a
	 * UtilEditor profile method, in addition to the ModuleContext.
	 *
	 * @param context
	 *            The Module Context of universAAL
	 * @param namespace
	 *            The namespace of your server, ending with the character #
	 * @param ontologyURI
	 *            The MY_URI of the class of Service ontology you are going to
	 *            implement
	 * @param path
	 *            The property path from the root of the Service ontology
	 *            concept to the exact concept you want to manage
	 * @param editedURI
	 *            The MY_URI of the class of the concept ontology that you want
	 *            to manage, which is at the end of the property path
	 */
	public UtilEditorCallee(ModuleContext context, String namespace, String ontologyURI, String[] path,
			String editedURI) {
		super(context, UtilEditor.getServiceProfiles(namespace, ontologyURI, path, editedURI));
		this.calleeNamespace = namespace;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.universAAL.middleware.service.ServiceCallee#handleCall(org.universAAL
	 * .middleware.service.ServiceCall)
	 */
	@Override
	public ServiceResponse handleCall(ServiceCall call) {
		if (call == null) {
			return null;
		}
		String operation = call.getProcessURI();
		if (operation == null) {
			return null;
		}
		if (operation.startsWith(calleeNamespace + UtilEditor.SERVICE_GET)) {
			Object input = call.getInputValue(calleeNamespace + UtilEditor.IN_GET);
			if (input == null) {
				return ERROR_INPUT;
			}
			Resource result = executeGet((Resource) input);
			ServiceResponse response = new ServiceResponse(CallStatus.succeeded);
			response.addOutput(new ProcessOutput(calleeNamespace + UtilEditor.OUT_GET, result));
			return response;
		}

		if (operation.startsWith(calleeNamespace + UtilEditor.SERVICE_ADD)) {
			Object input = call.getInputValue(calleeNamespace + UtilEditor.IN_ADD);
			if (input == null) {
				return ERROR_INPUT;
			}
			ServiceResponse response = new ServiceResponse(CallStatus.serviceSpecificFailure);
			if (executeAdd((Resource) input)) {
				response = new ServiceResponse(CallStatus.succeeded);
			}
			return response;
		}

		if (operation.startsWith(calleeNamespace + UtilEditor.SERVICE_CHANGE)) {
			Object input = call.getInputValue(calleeNamespace + UtilEditor.IN_CHANGE);
			if (input == null) {
				return ERROR_INPUT;
			}
			ServiceResponse response = new ServiceResponse(CallStatus.serviceSpecificFailure);
			if (executeChange((Resource) input)) {
				response = new ServiceResponse(CallStatus.succeeded);
			}
			return response;
		}

		if (operation.startsWith(calleeNamespace + UtilEditor.SERVICE_REMOVE)) {
			Object input = call.getInputValue(calleeNamespace + UtilEditor.IN_REMOVE);
			if (input == null) {
				return ERROR_INPUT;
			}
			ServiceResponse response = new ServiceResponse(CallStatus.serviceSpecificFailure);
			if (executeRemove((Resource) input)) {
				response = new ServiceResponse(CallStatus.succeeded);
			}
			return response;
		}

		ServiceResponse response = new ServiceResponse(CallStatus.serviceSpecificFailure);
		response.addOutput(new ProcessOutput(ServiceResponse.PROP_SERVICE_SPECIFIC_ERROR,
				&quot;The service requested has not been implemented in this simple editor callee&quot;));
		return response;
	}

	/**
	 * When a GET service request is received, this method is called
	 * automatically. The recommended purpose is to get a Resource with only a
	 * URI and return the matching complete Resource. Because it would be
	 * pointless to call this method if the client had the complete Resource.
	 * They only have the URI.
	 *
	 * @param input
	 *            The Resource object with the instance URI for which the GET is
	 *            issued. Take into account that only the instance URI is of
	 *            interest here. You can cast it to the right class as you
	 *            defined it in the constructor for the managedURI parameter.
	 * @return The complete Resource object with its full properties that is to
	 *         be returned.
	 */
	public abstract Resource executeGet(Resource input);

	/**
	 * When a ADD service request is received, this method is called
	 * automatically.
	 *
	 * @param input
	 *            The Resource object to add. You can cast it to the right class
	 *            as you defined it in the constructor for the managedURI
	 *            parameter.
	 * @return &lt;code&gt;true&lt;/code&gt; if the addition succeeded.
	 */
	public abstract boolean executeAdd(Resource input);

	/**
	 * When a CHANGE service request is received, this method is called
	 * automatically.
	 *
	 * @param input
	 *            The Resource object to change. It is assumed, although that is
	 *            up to the implementation, that the Resource to change already
	 *            existed. You can cast it to the right class as you defined it
	 *            in the constructor for the managedURI parameter.
	 * @return &lt;code&gt;true&lt;/code&gt; if the change succeeded.
	 */
	public abstract boolean executeChange(Resource input);

	/**
	 * When a REMOVE service request is received, this method is called
	 * automatically.
	 *
	 * @param input
	 *            The Resource object to remove. Take into account that only the
	 *            instance URI is of interest here. It is assumed, although that
	 *            is up to the implementation, that the Resource to remove
	 *            already existed. You can cast it to the right class as you
	 *            defined it in the constructor for the managedURI parameter.
	 * @return &lt;code&gt;true&lt;/code&gt; if the removal succeeded.
	 */
	public abstract boolean executeRemove(Resource input);

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/ui/DataTable.java</td>
<td>universAAL Support Utilities API</td>
<td>80</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/ui/DataTable.java</td>
<td>universAAL Utilities APIs</td>
<td>80</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class DataTable extends Control implements IContainer {

	/**
	 * Holds the data model.
	 */
	private Group model;
	/**
	 * Holds the items repeated.
	 */
	private List l = new ArrayList();
	/**
	 * Table parameter.
	 */
	private Boolean deletable = Boolean.FALSE;
	/**
	 * Table parameter.
	 */
	private Boolean editable = Boolean.FALSE;
	/**
	 * Table parameter.
	 */
	private Boolean expandable = Boolean.FALSE;

	/**
	 * Generic empty constructor. The Data table will be generated with default
	 * values (empty).
	 */
	public DataTable() {
	}

	/**
	 * Constructor with the reference of the Table Data Model to be used . The
	 * reference is a property path, but in this constructor it is simplified as
	 * a single String (a single-property path). All other properties of the
	 * input are set to defaults (empty). Use method setReference(String[] path)
	 * to set a path through several properties.
	 *
	 * If a root Resource is used in the parent of the Table (to which it is
	 * added) then the values reachable through the reference Path from the root
	 * will be used as Data Model for the Table.
	 * &lt;p/&gt;
	 * Example:
	 * &lt;p/&gt;
	 * &lt;code&gt;
	 * &lt;br/&gt;Location root=new Location(URI1);
	 * &lt;br/&gt;Location adj=new Location(URI2);
	 * &lt;br/&gt;root.addAdjacentLocation(adj);
	 * &lt;br/&gt;Dialog d=new Dialog(user,&quot;Title&quot;,root);
	 * &lt;br/&gt;DataTable rp=new DataTable(Location.PROP_IS_ADJACENT_TO);
	 * &lt;/code&gt;
	 * &lt;p/&gt;
	 * take into account that the referenced property must allow cardinality &gt; 1
	 *
	 * @param ref
	 *            The simple reference identifying the Table Data Model from the
	 *            parent root. Set to null to auto-generate and not use a Data
	 *            Model from the root.
	 */
	public DataTable(String ref) {
		setReference(ref);
	}

	/**
	 * Constructor with the reference of the Table Data Model to be used . The
	 * reference is a property path, but in this constructor it is simplified as
	 * a single String (a single-property path). All other properties of the
	 * input are set to defaults (empty). Use method setReference(String[] path)
	 * to set a path through several properties.
	 *
	 * If a root Resource is used in the parent of the Table (to which it is
	 * added) then the values reachable through the reference Path from the root
	 * will be used as Data Model for the Table.
	 * &lt;p/&gt;
	 * Example:
	 * &lt;p/&gt;
	 * &lt;code&gt;
	 * &lt;br/&gt;Location root=new Location(URI1);
	 * &lt;br/&gt;Location adj=new Location(URI2);
	 * &lt;br/&gt;root.addAdjacentLocation(adj);
	 * &lt;br/&gt;Dialog d=new Dialog(user,&quot;Title&quot;,root);
	 * &lt;br/&gt;DataTable rp=new DataTable(Location.PROP_IS_ADJACENT_TO);
	 * &lt;/code&gt;
	 * &lt;p/&gt;
	 * take into account that the referenced property must allow cardinality &gt; 1
	 *
	 * @param ref
	 *            The simple reference identifying the Table Data Model from the
	 *            parent root. Set to null to auto-generate and not use a Data
	 *            Model from the root.
	 * @param label
	 *            The label text that identifies the Table to the user.
	 */
	public DataTable(String ref, String label) {
		setReference(ref);
		this.label = new Label(label, null);
	}

	/**
	 * Constructor without reference of Table Data Model. Instead, the entries
	 * are passed explicitly, as an array of Resource elements. All of these
	 * elements in the array (the entries) must be of the same class, because
	 * their properties will be used by the controls in the Entry Model, for
	 * every entry. An automatic reference for the Table will be generated but
	 * only to identify it in the response.
	 *
	 * @param label
	 *            The label text that identifies the Table to the user.
	 * @param initialEntries
	 *            Array of Resources representing the entries of the Data Model.
	 */
	public DataTable(String label, Resource[] initialEntries) {
		this.label = new Label(label, null);
		setEntries(initialEntries);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.universAAL.support.utils.ui.Control#create(org.universAAL.middleware.
	 * ui.rdf.Group)
	 */
	public String[] create(Group group) {
		if (ref == null) {
			setReference(MY_NAMESPACE + StringUtils.createUniqueID());
		}
		Repeat r = new Repeat(group, label, ref, null, l.isEmpty() ? null : l);
		if (!deletable.booleanValue()) {
			r.banEntryDeletion();
		}
		if (!editable.booleanValue()) {
			r.banEntryEdit();
		}
		if (!expandable.booleanValue()) {
			r.banEntryAddition();
		}
		model = new Group(r, null, null, null, null);
		return ref.getThePath();
	}

	/**
	 * Add the given Simple Control UI element to the Table Entry Model. Submits
	 * and Data Tables ARE NOT ALLOWED and will not be added. The initial value
	 * of the Control MUST be null, because the value will be set to the Data
	 * Model entry property specified by the reference. The Control&#xfffd;s reference
	 * path must follow a valid path starting where the Table&#xfffd;s own path
	 * finished. Example:
	 *
	 * &lt;pre&gt;
	 * (Root) --PROP1-- (ResA) --PROP2-- (ResB)
	 *      _____________
	 *       Table Path      _____________
	 *                        Control Path
	 * &lt;/pre&gt;
	 *
	 * If the Table used explicit entries instead of a reference path, then the
	 * reference of the Controls must start with (or be) one of the properties
	 * of the type of Resource used for the explicit entries.
	 * &lt;p&gt;
	 * Once the control is added it cannot be modified. Controls are renedered
	 * in the same order they are added. Controls that are Containers and can
	 * add elements as well, like Group or DataTables, must be added BEFORE
	 * other controls can be added to them. Controls that need references, like
	 * Inputs (with property paths), or Submits (with IDs) will be given an
	 * automatic reference if none was set. This reference will be returned by
	 * this method, in the form of an Array of Strings representing the
	 * reference: a Path for Inputs, or a single String for Submits IDs.
	 *
	 * @param ctrl
	 *            The Simple Control UI element to be added.
	 * @return The Array of Strings representing the reference Property Path for
	 *         Input Controls, or with a single String for Submits IDs. Returns
	 *         null if attempted to add a SubmitCmd or DataTable.
	 */
	public String[] add(Control ctrl) {
		if ((ctrl instanceof SubmitCmd) || (ctrl instanceof DataTable)) {
			return null;
		}
		return ctrl.create(model);
	}

	/**
	 * Check if entries can be removed by the user.
	 *
	 * @return If entries can be removed by the user.
	 */
	public Boolean isDeletable() {
		return deletable;
	}

	/**
	 * Set if entries can be removed by the user.
	 *
	 * @param deletable
	 *            If entries can be removed by the user.
	 */
	public void setDeletable(Boolean deletable) {
		this.deletable = deletable;
	}

	/**
	 * Check if entries can be edited by the user.
	 *
	 * @return If entries can be edited by the user.
	 */
	public Boolean isEditable() {
		return editable;
	}

	/**
	 * Set if entries can be edited by the user.
	 *
	 * @param editable
	 *            If entries can be edited by the user.
	 */
	public void setEditable(Boolean editable) {
		this.editable = editable;
	}

	/**
	 * Check if entries can be added by the user.
	 *
	 * @return If entries can be added by the user.
	 */
	public Boolean isExpandable() {
		return expandable;
	}

	/**
	 * Set if entries can be added by the user.
	 *
	 * @param expandable
	 *            If entries can be added by the user.
	 */
	public void setExpandable(Boolean expandable) {
		this.expandable = expandable;
	}

	/**
	 * Get the entries of the Data Model backing up this Data Table.
	 *
	 * @return An array of Resources representing the entries in the Data Model.
	 */
	public Resource[] getEntries() {
		if (l != null &amp;&amp; !l.isEmpty()) {
			int i = 0;
			Resource[] res = new Resource[l.size()];
			Iterator iter = l.iterator();
			while (iter.hasNext()) {
				res[i++] = (Resource) iter.next();
			}
			return res;
		}
		return null;
	}

	/**
	 * Add an entry to the Data Model backing up this Data Table. Must be of the
	 * same class of those already added.
	 *
	 * @param option
	 *            The entry to add to the Data Model.
	 */
	public void addEntry(Resource entry) {
		l.add(entry);
	}

	/**
	 * Set the entries of the Data Model backing up this Data Table. Overrides
	 * any previous values.
	 *
	 * @param entries
	 *            An array of Resources representing the entries the Data Model.
	 */
	public void setEntries(Resource[] entries) {
		this.l = Arrays.asList(entries);
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/ui/SelectRange.java</td>
<td>universAAL Support Utilities API</td>
<td>47</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/ui/SelectRange.java</td>
<td>universAAL Utilities APIs</td>
<td>47</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class SelectRange extends InputControl {

	/**
	 * Min value.
	 */
	private Integer min = Integer.valueOf(0);
	/**
	 * Initial value.
	 */
	private Integer initialValue = Integer.valueOf(0);
	private Integer max = Integer.valueOf(1);
	private Integer step = null;

	/**
	 * Generic empty constructor. The Input will be generated with default
	 * values (0 to 1).
	 */
	public SelectRange() {
	}

	/**
	 * Constructor with the reference of the input to be used in request and
	 * response. The reference is a property path, but in this constructor it is
	 * simplified as a single String (a single-property path). All other
	 * properties of the input are set to defaults (0 to 1). Use method
	 * setReference(String[] path) to set a path through several properties.
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 */
	public SelectRange(String ref) {
		setReference(ref);
	}

	/**
	 * Constructor with the reference of the input to be used in request and
	 * response. The reference is a property path, but in this constructor it is
	 * simplified as a single String (a single-property path). Use method
	 * setReference(String[] path) to set a path through several properties.
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 * @param label
	 *            The label text that identifies the input to the user.
	 */
	public SelectRange(String ref, String label) {
		setReference(ref);
		this.label = new Label(label, null);
	}

	/**
	 * Constructor with the reference of the input to be used in request and
	 * response. The reference is a property path, but in this constructor it is
	 * simplified as a single String (a single-property path). Use method
	 * setReference(String[] path) to set a path through several properties.
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 * @param label
	 *            The label text that identifies the input to the user.
	 *
	 * @param min
	 *            The low end of the range that the value can get (inclusive)
	 * @param max
	 *            The high end of the range that the value can get (inclusive)
	 * @param initialValue
	 *            The value the range input has by default, between min and max.
	 *            If it is not changed by the user this will be the value of the
	 *            input in the response.
	 */
	public SelectRange(String ref, String label, int min, int max, int initialValue) {
		setReference(ref);
		this.label = new Label(label, null);
		setMinMaxInitial(min, max, initialValue);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.universAAL.support.utils.ui.Control#create(org.universAAL.middleware.
	 * ui.rdf.Group)
	 */
	public String[] create(Group group) {
		if (ref == null) {
			setReference(MY_NAMESPACE + StringUtils.createUniqueID());
		}
		model = new Range(group, label, ref, MergedRestriction.getAllValuesRestriction(ref.getLastPathElement(),
				new IntRestriction(min, true, max, true)), initialValue);
		if (step != null) {
			((Range) model).setStep(step);
		}
		return ref.getThePath();
	}

	/**
	 * Get the minimum value of the range.
	 *
	 * @return The minimum value
	 */
	public Integer getMin() {
		return min;
	}

	/**
	 * Set the minimum value of the range.
	 *
	 * @param min
	 *            The minimum value
	 */
	public void setMin(int min) {
		this.min = Integer.valueOf(min);
	}

	/**
	 * Get the initial value of the range, between min and max.
	 *
	 * @return The initial value
	 */
	public Integer getInitialValue() {
		return initialValue;
	}

	/**
	 * Set the initial value of the range, between min and max.
	 *
	 * @param initialValue
	 *            The initial value
	 */
	public void setInitialValue(int initialValue) {
		this.initialValue = Integer.valueOf(initialValue);
	}

	/**
	 * Get the maximum value of the range.
	 *
	 * @return The maximum value
	 */
	public Integer getMax() {
		return max;
	}

	/**
	 * Set the maximum value of the range.
	 *
	 * @param max
	 *            The maximum value
	 */
	public void setMax(int max) {
		this.max = Integer.valueOf(max);
	}

	/**
	 * Get the amount which the value increases or decreases with every step.
	 *
	 * @return The step value
	 */
	public Integer getStep() {
		return step;
	}

	/**
	 * Set the amount which the value increases or decreases with every step.
	 *
	 * @param step
	 *            The step value
	 */
	public void setStep(int step) {
		this.step = Integer.valueOf(step);
	}

	/**
	 * Set the minimum and maximum values of the range, and the initial value
	 * within them. The method does not check the validity, it is only checked
	 * when the control is added.
	 *
	 * @param min
	 *            The minimum value
	 * @param max
	 *            The maximum value
	 * @param initialValue
	 *            The initial value
	 */
	public void setMinMaxInitial(int min, int max, int initialValue) {
		this.min = Integer.valueOf(min);
		this.max = Integer.valueOf(max);
		this.initialValue = Integer.valueOf(initialValue);
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/ui/SubmitCmd.java</td>
<td>universAAL Support Utilities API</td>
<td>50</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/ui/SubmitCmd.java</td>
<td>universAAL Utilities APIs</td>
<td>50</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class SubmitCmd extends Control {

	/**
	 * Confirmation message for submit.
	 */
	protected String confirmMessage = null;
	/**
	 * Type of confirmation message.
	 */
	protected int confirmType = Submit.CONFIRMATION_TYPE_OK_CANCEL;
	/**
	 * List of required mandatory inputs.
	 */
	protected List l = new ArrayList();
	/**
	 * Hidden object associated with the submit
	 */
	protected Object h = null;
	/**
	 * Auxiliary property URI for the path to reach the hidden object.
	 */
	public static final String HIDDENREF = MY_NAMESPACE + &quot;hiddenRef&quot;;

	/**
	 * Generic empty constructor. The Submit will be generated with default
	 * values (empty).
	 */
	public SubmitCmd() {
	}

	/**
	 * Constructor with the reference of the submit to be used in request and
	 * response. The reference is a single ID String. All other properties of
	 * the input are set to defaults (empty).
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 */
	public SubmitCmd(String ref) {
		setReference(ref);
	}

	/**
	 * Constructor with the reference of the submit to be used in request and
	 * response. The reference is a single ID String.
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 * @param label
	 *            The label text that identifies the submit to the user.
	 */
	public SubmitCmd(String ref, String label) {
		setReference(ref);
		this.label = new Label(label, null);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.universAAL.support.utils.ui.Control#create(org.universAAL.middleware.
	 * ui.rdf.Group)
	 */
	public String[] create(Group group) {
		if (ref == null) {
			setReference(MY_NAMESPACE + StringUtils.createUniqueID());
		}
		Submit sub = new Submit(group, label, ref.getLastPathElement());
		if (confirmMessage != null) {
			switch (confirmType) {
			case Submit.CONFIRMATION_TYPE_OK_CANCEL:
				sub.setConfirmationOkCancel(confirmMessage);
				break;
			case Submit.CONFIRMATION_TYPE_YES_NO:
				sub.setConfirmationYesNo(confirmMessage);
				break;
			default:
				sub.setConfirmationOkCancel(confirmMessage);
				break;
			}
		}
		if (!l.isEmpty()) {
			Iterator iter = l.iterator();
			while (iter.hasNext()) {
				sub.addMandatoryInput((Input) iter.next());
			}
		}
		if (h != null) {
			Path hiddenPath = Path.parse(ref.getThePath());
			sub.getFormObject().getData().setPropertyPath(hiddenPath.to(HIDDENREF).path, h, true);
		}
		return ref.getThePath();
	}

	/**
	 * Indicates that the InputControl passed as parameter must be filled with a
	 * value by the user before this Submit is pressed.
	 *
	 * @param input
	 *            The InputControl to make mandatory for this Submit.
	 */
	public void addMandatoryInput(InputControl input) {
		Input in = input.getModel();
		l.add(in);
	}

	/**
	 * Associate an object to a submit so it is sent within the UI request, but
	 * not shown to the user. When the UI response is being handled by the UI
	 * caller, this hidden input can be retrieved by calling
	 * &lt;code&gt;uiresponse.getUserInput( new String[] { REFSUBMIT, SubmitCmd.HIDDENREF });&lt;/code&gt;
	 * &lt;p&gt;
	 * This is useful when you are building a list of items in a form, each of
	 * which has a Submit associated to them. You can use this method to know,
	 * later when handling the response, which item of the list had its Submit
	 * pressed. Tip: to do this it's useful that all the references of these
	 * listed submits start with the same string, so you can detect any of them
	 * when handling the response, and then get the exact submission ID for use
	 * as REFSUBMIT in the example above.
	 *
	 * @param hidden
	 *            The InputControl to make mandatory for this Submit.
	 */
	public void setHiddenObject(Object hidden) {
		h = hidden;
	}

	/**
	 * Get the confirmation message that will appear when this Submit is
	 * selected by the user. Confirmation is for avoiding accidental selection
	 * of important Submits.
	 *
	 * @return The confirmation message.
	 */
	public String getConfirmMessage() {
		return confirmMessage;
	}

	/**
	 * Set the confirmation message that will appear when this Submit is
	 * selected by the user. Confirmation is for avoiding accidental selection
	 * of important Submits.
	 *
	 * @param confirmMessage
	 *            The confirmation message.
	 */
	public void setConfirmMessage(String confirmMessage) {
		this.confirmMessage = confirmMessage;
	}

	/**
	 * Set the confirmation message that will appear when this Submit is
	 * selected by the user. Confirmation is for avoiding accidental selection
	 * of important Submits.
	 *
	 * @param confirmMessage
	 *            The confirmation message.
	 * @param confirmType
	 *            The type of confirmation. One of
	 *            org.universAAL.middleware.ui.rdf
	 *            .Submit.CONFIRMATION_TYPE_OK_CANCEL (0) or
	 *            org.universAAL.middleware
	 *            .ui.rdf.Submit.CONFIRMATION_TYPE_YES_NO (1)
	 */
	public void setConfirmMessage(String confirmMessage, int confirmType) {
		this.confirmMessage = confirmMessage;
		this.confirmType = confirmType;
	}

	/**
	 * Get the type of confirmation message.
	 *
	 * @return The type of confirmation. One of org.universAAL.middleware.ui.rdf
	 *         .Submit.CONFIRMATION_TYPE_OK_CANCEL (0) or
	 *         org.universAAL.middleware .ui.rdf.Submit.CONFIRMATION_TYPE_YES_NO
	 *         (1)
	 */
	public int getConfirmType() {
		return confirmType;
	}

	/**
	 * Set the type of confirmation message.
	 *
	 * @param confirmType
	 *            The type of confirmation. One of
	 *            org.universAAL.middleware.ui.rdf
	 *            .Submit.CONFIRMATION_TYPE_OK_CANCEL (0) or
	 *            org.universAAL.middleware
	 *            .ui.rdf.Submit.CONFIRMATION_TYPE_YES_NO (1)
	 */
	public void setConfirmType(int confirmType) {
		this.confirmType = confirmType;
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/ui/low/Dialog.java</td>
<td>universAAL Support Utilities API</td>
<td>77</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/ui/low/Dialog.java</td>
<td>universAAL Utilities APIs</td>
<td>77</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class Dialog extends UIRequest implements IContainer {

	/**
	 * Use this helper class to create a UIRequest that is easy to use. This
	 * Dialog extends UIRequest so you can use it with a UICaller. Default
	 * values are used for priority (low) and privacy (insensible).
	 *
	 * @param user
	 *            The user to which the request is addressed.
	 * @param title
	 *            The title of the Dialog.
	 */
	public Dialog(User user, String title) {
		super();
		addType(MY_URI, true);
		configInstance(user, title, (Resource) null, LevelRating.low, PrivacyLevel.insensible);
	}

	/**
	 * Use this helper class to create a UIRequest that is easy to use. This
	 * Dialog extends UIRequest so you can use it with a UICaller. This
	 * constructor can get a root Resource from which references to Controls can
	 * be reused. When creating a Form Control, pass it the property path in the
	 * root Resource to the right value and it will be set as initial value for
	 * that Control. Default values are used for priority (low) and privacy
	 * (insensible).
	 *
	 * @param user
	 *            The user to which the request is addressed.
	 * @param title
	 *            The title of the Dialog.
	 * @param root
	 *            The Resource to use as root for the contained Form Controls.
	 */
	public Dialog(User user, String title, Resource root) {
		super();
		addType(MY_URI, true);
		configInstance(user, title, root, LevelRating.low, PrivacyLevel.insensible);
	}

	/**
	 * Use this helper class to create a UIRequest that is easy to use. This
	 * Dialog extends UIRequest so you can use it with a UICaller.
	 *
	 * @param user
	 *            The user to which the request is addressed.
	 * @param title
	 *            The title of the Dialog.
	 * @param priority
	 *            Set a custom priority for the Dialog.
	 * @param privacy
	 *            Set the required privacy level for the Dialog.
	 */
	public Dialog(User user, String title, LevelRating priority, PrivacyLevel privacy) {
		super();
		addType(MY_URI, true);
		configInstance(user, title, (Resource) null, priority, privacy);
	}

	/**
	 * Use this helper class to create a UIRequest that is easy to use. This
	 * Dialog extends UIRequest so you can use it with a UICaller. This
	 * constructor can get a root Resource from which references to Controls can
	 * be reused. When creating a Form Control, pass it the property path in the
	 * root Resource to the right value and it will be set as initial value for
	 * that Control.
	 *
	 * @param user
	 *            The user to which the request is addressed.
	 * @param title
	 *            The title of the Dialog.
	 * @param root
	 *            The Resource to use as root for the contained Form Controls.
	 * @param priority
	 *            Set a custom priority for the Dialog.
	 * @param privacy
	 *            Set the required privacy level for the Dialog.
	 */
	public Dialog(User user, String title, Resource root, LevelRating priority, PrivacyLevel privacy) {
		super();
		addType(MY_URI, true);
		configInstance(user, title, root, priority, privacy);
	}

	/**
	 * Sets the properties of the request to the right initial values specified
	 * by the constructors.
	 *
	 * @param user
	 *            The user to which the request is addressed.
	 * @param title
	 *            The title of the Dialog.
	 * @param root
	 *            The Resource to use as root for the contained Form Controls.
	 * @param priority
	 *            Set a custom priority for the Dialog.
	 * @param privacy
	 *            Set the required privacy level for the Dialog.
	 */
	private void configInstance(User user, String title, Resource root, LevelRating priority, PrivacyLevel privacy) {
		props.put(PROP_ADDRESSED_USER, user);
		props.put(PROP_DIALOG_FORM, Form.newDialog(title, root));
		props.put(PROP_DIALOG_PRIORITY, priority);
		props.put(PROP_DIALOG_LANGUAGE, Locale.getDefault());
		props.put(PROP_DIALOG_PRIVACY_LEVEL, privacy);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.universAAL.support.utils.ui.IContainer#add(org.universAAL.samples.ui.
	 * utils.SimpleControl)
	 */
	public String[] add(Control ctrl) {
		return ctrl.create(getDialogForm().getIOControls());
	}

	/**
	 * Add a Submit Form Control to the Submit group of the Dialog. Submit group
	 * is for Submits that end the dialog or lead to new dialogs.
	 *
	 * @param ctrl
	 *            The Submit to add
	 * @return The String representing the ID to be used to identify the Submit
	 *         in the response.
	 */
	public String addSubmit(SubmitCmd ctrl) {
		String[] ref = ctrl.create(getDialogForm().getSubmits());
		return ref[ref.length - 1];
	}

	/**
	 * Add a hidden object so it is sent within the UI request, but not shown to
	 * the user. When the UI response is being handled by the UI caller, this
	 * hidden input can be retrieved by calling
	 * &lt;code&gt;uiresponse.getUserInput(new String[]{ref});&lt;/code&gt; , being
	 * &lt;code&gt;ref&lt;/code&gt; the one you used in this method.
	 *
	 * @param ref
	 *            The reference you will use to access the hidden object later
	 *            from the response
	 * @param hidden
	 *            The object you want to hide
	 */
	public void addHidden(String ref, Object hidden) {
		this.getDialogForm().getData().setPropertyPath(new String[] { ref }, hidden);
	}

	/**
	 * Add an extra property to the form used in this UI request. Extra
	 * properties may be used by I/O Handlers to allow the developer to
	 * fine-tune things like the layout. The equivalent in native API is to call
	 * setProperty() on a Form object. Use this only as recommended by the
	 * Handler you intend to use, since it is the Handler the one who will
	 * interpret the property.
	 *
	 * @param property
	 *            The property of a Form that a certain Handler will inspect for
	 *            its own purposes.
	 * @param extra
	 *            The value to be set into the property.
	 */
	public void addExtra(String property, Object extra) {
		this.getDialogForm().setProperty(property, extra);
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/ui/low/SubDialog.java</td>
<td>universAAL Support Utilities API</td>
<td>78</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/ui/low/SubDialog.java</td>
<td>universAAL Utilities APIs</td>
<td>78</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class SubDialog extends UIRequest implements IContainer {

	/**
	 * Use this helper class to create a UIRequest that is easy to use. This
	 * SubDialog extends UIRequest so you can use it with a UICaller. This
	 * constructor needs the URI of the Dialog that triggers this SubDialog.
	 * Default values are used for priority (low) and privacy (insensible).
	 *
	 * @param user
	 *            The user to which the request is addressed.
	 * @param title
	 *            The title of the Dialog.
	 * @param parentDialogURI
	 *            The URI of the Dialog that triggered this SubDialog.
	 */
	public SubDialog(User user, String title, String parentDialogURI) {
		super();
		addType(MY_URI, true);
		configInstance(user, title, parentDialogURI, LevelRating.low, PrivacyLevel.insensible);
	}

	/**
	 * Use this helper class to create a UIRequest that is easy to use. This
	 * SubDialog extends UIRequest so you can use it with a UICaller. This
	 * constructor needs the URI of the Dialog that triggers this SubDialog.
	 *
	 * @param user
	 *            The user to which the request is addressed.
	 * @param title
	 *            The title of the Dialog.
	 * @param parentDialogURI
	 *            The URI of the Dialog that triggered this SubDialog.
	 * @param priority
	 *            Set a custom priority for the SubDialog.
	 * @param privacy
	 *            Set the required privacy level for the SubDialog.
	 */
	public SubDialog(User user, String title, String parentDialogURI, LevelRating priority, PrivacyLevel privacy) {
		super();
		addType(MY_URI, true);
		configInstance(user, title, parentDialogURI, priority, privacy);
	}

	/**
	 * Sets the properties of the request to the right initial values specified
	 * by the constructors.
	 *
	 * @param user
	 *            The user to which the request is addressed.
	 * @param title
	 *            The title of the Dialog.
	 * @param parentDialogURI
	 *            The URI of the Dialog that triggered this SubDialog.
	 * @param priority
	 *            Set a custom priority for the SubDialog.
	 * @param privacy
	 *            Set the required privacy level for the SubDialog.
	 */
	private void configInstance(User user, String title, String parentDialogURI, LevelRating priority,
			PrivacyLevel privacy) {
		props.put(PROP_ADDRESSED_USER, user);
		props.put(PROP_DIALOG_FORM, Form.newSubdialog(title, parentDialogURI));
		props.put(PROP_DIALOG_PRIORITY, priority);
		props.put(PROP_DIALOG_LANGUAGE, Locale.getDefault());
		props.put(PROP_DIALOG_PRIVACY_LEVEL, privacy);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.universAAL.support.utils.ui.IContainer#add(org.universAAL.samples.ui.
	 * utils.SimpleControl)
	 */
	public String[] add(Control ctrl) {
		return ctrl.create(getDialogForm().getIOControls());
	}

	/**
	 * Add a Submit Form Control to the Submit group of the SubDialog. Submit
	 * group is for Submits that end the SubDialog or lead to new dialogs.
	 *
	 * @param ctrl
	 *            The Submit to add
	 * @return The String representing the ID to be used to identify the Submit
	 *         in the response.
	 */
	public String addSubmit(SubmitCmd ctrl) {
		String[] ref = ctrl.create(getDialogForm().getSubmits());
		return ref[ref.length - 1];
	}

	/**
	 * Add a hidden object so it is sent within the UI request, but not shown to
	 * the user. When the UI response is being handled by the UI caller, this
	 * hidden input can be retrieved by calling
	 * &lt;code&gt;uiresponse.getUserInput(new String[]{ref});&lt;/code&gt; , being
	 * &lt;code&gt;ref&lt;/code&gt; the one you used in this method.
	 *
	 * @param ref
	 *            The reference you will use to access the hidden object later
	 *            from the response
	 * @param hidden
	 *            The object you want to hide
	 */
	public void addHidden(String ref, Object hidden) {
		this.getDialogForm().getData().setPropertyPath(new String[] { ref }, hidden);
	}

	/**
	 * Add an extra property to the form used in this UI request. Extra
	 * properties may be used by I/O Handlers to allow the developer to
	 * fine-tune things like the layout. The equivalent in native API is to call
	 * setProperty() on a Form object. Use this only as recommended by the
	 * Handler you intend to use, since it is the Handler the one who will
	 * interpret the property.
	 *
	 * @param property
	 *            The property of a Form that a certain Handler will inspect for
	 *            its own purposes.
	 * @param extra
	 *            The value to be set into the property.
	 */
	public void addExtra(String property, Object extra) {
		this.getDialogForm().setProperty(property, extra);
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/ui/SelectMulti.java</td>
<td>universAAL Support Utilities API</td>
<td>58</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/ui/SelectMulti.java</td>
<td>universAAL Utilities APIs</td>
<td>58</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class SelectMulti extends InputControl {

	/**
	 * Initial selected index.
	 */
	protected Integer initialValue;
	/**
	 * List of options.
	 */
	private List l = new ArrayList();

	/**
	 * Generic empty constructor. The Input will be generated with default
	 * values (first).
	 */
	public SelectMulti() {
	}

	/**
	 * Constructor with the reference of the input to be used in request and
	 * response. The reference is a property path, but in this constructor it is
	 * simplified as a single String (a single-property path). All other
	 * properties of the input are set to defaults (first). Use method
	 * setReference(String[] path) to set a path through several properties.
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 */
	public SelectMulti(String ref) {
		setReference(ref);
	}

	/**
	 * Constructor with the reference of the input to be used in request and
	 * response. The reference is a property path, but in this constructor it is
	 * simplified as a single String (a single-property path). Use method
	 * setReference(String[] path) to set a path through several properties.
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 * @param label
	 *            The label text that identifies the input to the user.
	 */
	public SelectMulti(String ref, String label) {
		setReference(ref);
		this.label = new Label(label, null);
	}

	/**
	 * Constructor with the reference of the input to be used in request and
	 * response. The reference is a property path, but in this constructor it is
	 * simplified as a single String (a single-property path). All other
	 * properties of the input are set to defaults (first). Use method
	 * setReference(String[] path) to set a path through several properties.
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 * @param label
	 *            The label text that identifies the input to the user.
	 * @param initialOptions
	 *            An array of Objects that represent the different possible
	 *            options to select.
	 */
	public SelectMulti(String ref, String label, Object[] initialOptions) {
		setReference(ref);
		this.label = new Label(label, null);
		setOptions(initialOptions);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.universAAL.support.utils.ui.Control#create(org.universAAL.middleware.
	 * ui.rdf.Group)
	 */
	public String[] create(Group group) {
		if (ref == null) {
			setReference(MY_NAMESPACE + StringUtils.createUniqueID());
		}
		model = new Select(group, label, ref, null,
				initialValue != null ? getOptions()[initialValue.intValue()] : null);
		((Select) model).generateChoices(getOptions());
		// TODO: use storeUserInput for the initial value, because it seems
		// generatechoices overrides it
		return ref.getThePath();
	}

	/**
	 * Get the initial value of the selection as an index in the array of
	 * options.
	 *
	 * @return The index of the initial value
	 */
	public Integer getInitialIndex() {
		return initialValue;
	}

	/**
	 * Set the initial value of the selection as the index in the array of
	 * options.
	 *
	 * @param initialIndex
	 *            The index of the initial value
	 */
	public void setInitialIndex(Integer initialIndex) {
		this.initialValue = initialIndex;
	}

	/**
	 * Get the possible options to select.
	 *
	 * @return An array of Strings representing the different options to select,
	 *         or null if none were set.
	 */
	public Object[] getOptions() {
		if (l != null &amp;&amp; !l.isEmpty()) {

			return l.toArray();

			// int i=0;
			// String[] res=new String[l.size()];
			// Iterator iter=l.iterator();
			// while(iter.hasNext()){
			// res[i++]=(String)iter.next();
			// }
			// return res;
		}
		return null;
	}

	/**
	 * Add an option to the list of possible options. It will be added in the
	 * last place.
	 *
	 * @param option
	 *            The option to add
	 */
	public void addOption(Object option) {
		l.add(option);
	}

	/**
	 * Get the possible options to select. Overrides any previous values.
	 *
	 * @param options
	 *            The array of Strings representing the different options to
	 *            select
	 */
	public void setOptions(Object[] options) {
		this.l = Arrays.asList(options);
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/service/top/UtilActuatorCallee.java</td>
<td>universAAL Support Utilities API</td>
<td>46</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/service/top/UtilActuatorCallee.java</td>
<td>universAAL Utilities APIs</td>
<td>46</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public abstract class UtilActuatorCallee extends ServiceCallee {

	/**
	 * Namespace for auxiliary URIs used in this class.
	 */
	private String calleeNamespace;

	/**
	 * Default error response.
	 */
	private ServiceResponse errorResponse = new ServiceResponse(CallStatus.serviceSpecificFailure);

	/**
	 * Default constructor of the class. Takes the same parameters needed by a
	 * UtilActuator profile method, in addition to the ModuleContext.
	 * &lt;p&gt;
	 * BE CAREFUL: This will only work with actuators that have StatusValue as
	 * HAS_VALUE property. Others, like DimmerActuator, will throw an exception.
	 *
	 * @param context
	 *            The Module Context of universAAL
	 * @param namespace
	 *            The namespace of your server, ending with the character #
	 * @param actuator
	 *            The ontology instance of the actuator you are controlling. The
	 *            more properties it has set, the better.
	 * @throws InvalidOntologyUtilException
	 *             when an actuator is passed that is does not have StatusValue
	 *             as type restriction of its HAS_VALUE property
	 */
	public UtilActuatorCallee(ModuleContext context, String namespace, Actuator actuator)
			throws InvalidOntologyUtilException {
		super(context, UtilActuator.getServiceProfiles(namespace, actuator));
		this.calleeNamespace = namespace;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.universAAL.middleware.service.ServiceCallee#handleCall(org.universAAL
	 * .middleware.service.ServiceCall)
	 */
	@Override
	public ServiceResponse handleCall(ServiceCall call) {
		if (call == null) {
			return null;
		}
		String operation = call.getProcessURI();
		if (operation == null) {
			return null;
		}
		if (operation.startsWith(calleeNamespace + UtilActuator.SERVICE_GET_ON_OFF)) {
			boolean result = executeGet();
			ServiceResponse response = new ServiceResponse(CallStatus.succeeded);
			response.addOutput(new ProcessOutput(calleeNamespace + UtilActuator.OUT_GET_ON_OFF,
					result ? StatusValue.Activated : StatusValue.NotActivated));
			return response;
		}

		if (operation.startsWith(calleeNamespace + UtilActuator.SERVICE_TURN_OFF)) {
			if (executeOff()) {
				return new ServiceResponse(CallStatus.succeeded);
			} else {
				return errorResponse;
			}

		}

		if (operation.startsWith(calleeNamespace + UtilActuator.SERVICE_TURN_ON)) {
			if (executeOn()) {
				return new ServiceResponse(CallStatus.succeeded);
			} else {
				return errorResponse;
			}
		}

		errorResponse.addOutput(new ProcessOutput(ServiceResponse.PROP_SERVICE_SPECIFIC_ERROR,
				&quot;The service requested has not been implemented in this simple editor callee&quot;));
		return errorResponse;
	}

	/**
	 * When a SET ON service request is received, this method is called
	 * automatically.
	 *
	 * @return &lt;code&gt;true&lt;/code&gt; if the actuator could be set to ON
	 */
	public abstract boolean executeOn();

	/**
	 * When a SET OFF service request is received, this method is called
	 * automatically.
	 *
	 * @return &lt;code&gt;true&lt;/code&gt; if the actuator could be set to OFF
	 */
	public abstract boolean executeOff();

	/**
	 * When a GET STATUS service request is received, this method is called
	 * automatically.
	 *
	 * @return The Boolean value representing the status property of the
	 *         actuator.
	 */
	public abstract boolean executeGet();

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/ui/low/Message.java</td>
<td>universAAL Support Utilities API</td>
<td>67</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/ui/low/Message.java</td>
<td>universAAL Utilities APIs</td>
<td>67</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class Message extends UIRequest implements IContainer {

	/**
	 * Use this helper class to create a UIRequest that is easy to use. This
	 * Message extends UIRequest so you can use it with a UICaller. Default
	 * values are used for priority (low) and privacy (insensible).
	 *
	 * @param user
	 *            The user to which the request is addressed.
	 * @param title
	 *            The title of the Message.
	 * @param message
	 *            The default output message to be shown to the user.
	 */
	public Message(User user, String title, String message) {
		super();
		addType(MY_URI, true);
		configInstance(user, title, message, LevelRating.low, PrivacyLevel.insensible);
	}

	/**
	 * Use this helper class to create a UIRequest that is easy to use. This
	 * Message extends UIRequest so you can use it with a UICaller.
	 *
	 * @param user
	 *            The user to which the request is addressed.
	 * @param title
	 *            The title of the Message.
	 * @param message
	 *            The default output message to be shown to the user.
	 * @param priority
	 *            Set a custom priority for the Message.
	 * @param privacy
	 *            Set the required privacy level for the Message.
	 */
	public Message(User user, String title, String message, LevelRating priority, PrivacyLevel privacy) {
		super();
		addType(MY_URI, true);
		configInstance(user, title, message, priority, privacy);
	}

	/**
	 * Sets the properties of the request to the right initial values specified
	 * by the constructors.
	 *
	 * @param user
	 *            The user to which the request is addressed.
	 * @param title
	 *            The title of the Message.
	 * @param message
	 *            The default output message to be shown to the user.
	 * @param priority
	 *            Set a custom priority for the Message.
	 * @param privacy
	 *            Set the required privacy level for the Message.
	 */
	private void configInstance(User user, String title, String message, LevelRating priority, PrivacyLevel privacy) {
		props.put(PROP_ADDRESSED_USER, user);
		props.put(PROP_DIALOG_FORM, Form.newMessage(title, message));
		props.put(PROP_DIALOG_PRIORITY, priority);
		props.put(PROP_DIALOG_LANGUAGE, Locale.getDefault());
		props.put(PROP_DIALOG_PRIVACY_LEVEL, privacy);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * oorg.universAAL.support.utils.ui.IContainer#add(org.universAAL.samples.ui
	 * .utils.SimpleControl)
	 */
	public String[] add(Control ctrl) {
		return ctrl.create(getDialogForm().getIOControls());
	}

	/**
	 * Add a Submit Form Control to the Submit group of the Message. Submit
	 * group is for Submits that end the message. By default two Submits are
	 * added by the system, Delete and Preserve.
	 *
	 * @param ctrl
	 *            The Submit to add
	 * @return The String representing the ID to be used to identify the Submit
	 *         in the response.
	 */
	public String addSubmit(SubmitCmd ctrl) {
		String[] ref = ctrl.create(getDialogForm().getSubmits());
		return ref[ref.length - 1];
	}

	/**
	 * Add a hidden object so it is sent within the UI request, but not shown to
	 * the user. When the UI response is being handled by the UI caller, this
	 * hidden input can be retrieved by calling
	 * &lt;code&gt;uiresponse.getUserInput(new String[]{ref});&lt;/code&gt; , being
	 * &lt;code&gt;ref&lt;/code&gt; the one you used in this method.
	 *
	 * @param ref
	 *            The reference you will use to access the hidden object later
	 *            from the response
	 * @param hidden
	 *            The object you want to hide
	 */
	public void addHidden(String ref, Object hidden) {
		this.getDialogForm().getData().setPropertyPath(new String[] { ref }, hidden);
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/ui/Forms.java</td>
<td>universAAL Support Utilities API</td>
<td>44</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/ui/Forms.java</td>
<td>universAAL Utilities APIs</td>
<td>44</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class Forms {

	private Forms() {
		// Disallow instantiating
	}

	/**
	 * Create a Area control.
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 * @param label
	 *            The label text that identifies the input to the user.
	 * @return The Area
	 */
	public static Area area(String ref, String label) {
		return new Area(ref, label);
	}

	/**
	 * Create a Area control.
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 * @param label
	 *            The label text that identifies the input to the user.
	 * @return The Area
	 */
	public static Check check(String ref, String label) {
		return new Check(ref, label);
	}

	/**
	 * Create a Media control.
	 *
	 * @param label
	 *            The label text that identifies the output to the user.
	 * @param url
	 *            The URL to the value to be displayed, from the Resource
	 *            server.
	 * @return The Media
	 */
	public static Media media(String label, String url) {
		return new Media(label, url);
	}

	/**
	 * Create a Out control.
	 *
	 * @param label
	 *            The label text that identifies the output to the user.
	 * @param value
	 *            The output value to be displayed.
	 * @return The Out
	 */
	public static Out out(String label, String value) {
		return new Out(label, value);
	}

	/**
	 * Create a SelectRange control.
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 * @param label
	 *            The label text that identifies the input to the user.
	 * @param min
	 *            The low end of the range that the value can get (inclusive)
	 * @param max
	 *            The high end of the range that the value can get (inclusive)
	 * @return The SelectRange
	 */
	public static SelectRange range(String ref, String label, int min, int max) {
		return new SelectRange(ref, label, min, max, min);
	}

	/**
	 * Create a SelectMulti control.
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 * @param label
	 *            The label text that identifies the input to the user.
	 * @param initialOptions
	 *            An array of Strings that represent the different possible
	 *            options to select.
	 * @return The SelectMulti
	 */
	public static SelectMulti multi(String ref, String label, String[] initialOptions) {
		return new SelectMulti(ref, label, initialOptions);
	}

	/**
	 * Create a SelectOne control.
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 * @param label
	 *            The label text that identifies the input to the user.
	 * @param initialOptions
	 *            An array of Strings that represent the different possible
	 *            options to select.
	 * @return The SelectOne
	 */
	public static SelectOne one(String ref, String label, String[] initialOptions) {
		return new SelectOne(ref, label, initialOptions);
	}

	/**
	 * Create a SubmitCmd control.
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 * @param label
	 *            The label text that identifies the submit to the user.
	 * @return The SubmitCmd
	 */
	public static SubmitCmd submit(String ref, String label) {
		return new SubmitCmd(ref, label);
	}

	/**
	 * Create a Text control.
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 * @param label
	 *            The label text that identifies the input to the user.
	 * @return The Text
	 */
	public static Text text(String ref, String label) {
		return new Text(ref, label);
	}

	/**
	 * Create a TriggerCmd control.
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 * @param label
	 *            The label text that identifies the submit to the user.
	 * @return The TriggerCmd
	 */
	public static TriggerCmd trigger(String ref, String label) {
		return new TriggerCmd(ref, label);
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/context/low/Provider.java</td>
<td>universAAL Support Utilities API</td>
<td>43</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/context/low/Provider.java</td>
<td>universAAL Utilities APIs</td>
<td>43</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class Provider extends ContextProvider {

	/**
	 * Simple constructor to create a &lt;b&gt;gauge&lt;/b&gt; Context Provider with no
	 * restrictions on the provided events. This means the provided events can
	 * be of any type.
	 *
	 * @param uri
	 *            The URI that identifies the Context Provider.
	 */
	public Provider(String uri) {
		super(uri);
		this.setType(ContextProviderType.gauge);
		this.setProvidedEvents(new ContextEventPattern[] { new ContextEventPattern() });
	}

	/**
	 * Simple constructor to create a Context Provider of a given type with no
	 * restrictions on the provided events. This means the provided events can
	 * be of any type.
	 *
	 * @param uri
	 *            The URI that identifies the Context Provider.
	 * @param type
	 *            The type of Context Provider, one of Gauge, Controller or
	 *            Reasoner
	 */
	public Provider(String uri, ContextProviderType type) {
		super(uri);
		this.setType(type != null ? type : ContextProviderType.gauge);
		this.setProvidedEvents(new ContextEventPattern[] { new ContextEventPattern() });
	}

	/**
	 * Simple constructor to create a Context Provider of a given type with the
	 * given restrictions on the provided events.
	 *
	 * @param uri
	 *            The URI that identifies the Context Provider.
	 * @param type
	 *            The type of Context Provider, one of Gauge, Controller or
	 *            Reasoner.
	 * @param events
	 *            Array of Patterns describing the provided events, as normally
	 *            used in the native API.
	 */
	public Provider(String uri, ContextProviderType type, ContextEventPattern[] events) {
		super(uri);
		this.setType(type != null ? type : ContextProviderType.gauge);
		this.setProvidedEvents(events);
	}

	/**
	 * Simple constructor to create a Context Provider of a given type with the
	 * given restrictions on the subject, the predicate, and the object of the
	 * provided events.
	 *
	 * @param uri
	 *            The URI that identifies the Context Provider.
	 * @param type
	 *            The type of Context Provider, one of Gauge, Controller or
	 *            Reasoner
	 * @param subjTypeURI
	 *            The type URI that the provided events subject must have. Null
	 *            for any.
	 * @param predicate
	 *            The exact predicate that the provided events must equal. Null
	 *            for any.
	 * @param objTypeURI
	 *            The type URI that the provided events object must have. Null
	 *            for any.
	 */
	public Provider(String uri, ContextProviderType type, String subjTypeURI, String predicate, String objTypeURI) {
		super(uri);
		this.setType(type != null ? type : ContextProviderType.gauge);
		this.setProvidedEvents(new ContextEventPattern[] { new Pattern(subjTypeURI, predicate, objTypeURI) });
	}

	/**
	 * Simple constructor to create a Context Provider of a given type with the
	 * given restrictions on the subject, the predicate, and the object of the
	 * provided events.
	 *
	 * @param uri
	 *            The URI that identifies the Context Provider.
	 * @param type
	 *            The type of Context Provider, one of Gauge, Controller or
	 *            Reasoner
	 * @param subj
	 *            The exact instance that the provided events subject must
	 *            equal. Null for any.
	 * @param predicate
	 *            The exact predicate that the provided events must equal. Null
	 *            for any.
	 * @param objTypeURI
	 *            The type URI that the provided events object must have. Null
	 *            for any.
	 */
	public Provider(String uri, ContextProviderType type, ManagedIndividual subj, String predicate, String objTypeURI) {
		super(uri);
		this.setType(type != null ? type : ContextProviderType.gauge);
		this.setProvidedEvents(new ContextEventPattern[] { new Pattern(subj, predicate, objTypeURI) });
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/service/Value.java</td>
<td>universAAL Support Utilities API</td>
<td>41</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/service/Value.java</td>
<td>universAAL Utilities APIs</td>
<td>41</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public abstract class Value {
	/**
	 * Holds the URI of the argument.
	 */
	protected String uri;
	/**
	 * Determines if it was set by Value or by type URI.
	 */
	protected boolean isByURI = true;

	protected static Object createEmptyInstance(String uri) {
		try {
			Class c = TypeMapper.getJavaClass(uri);
			if (c.equals(XMLGregorianCalendar.class)) {
				return DatatypeFactory.newInstance().newXMLGregorianCalendar();
			} else if (c.equals(Duration.class)) {
				return DatatypeFactory.newInstance().newDuration(0);
			} else if (c.equals(Boolean.class)) {
				return Boolean.FALSE;
			} else if (c.equals(Locale.class)) {
				return Locale.getDefault();
			} else if (c.equals(Integer.class) || c.equals(Double.class) || c.equals(Float.class)
					|| c.equals(Long.class) || c.equals(NonNegativeInteger.class)) {
				return c.getConstructor(String.class).newInstance(&quot;0&quot;);
			} else {
				return c.getConstructor().newInstance();
			}
		} catch (Exception e) {
			System.out.println(
					&quot;---SIMPLE UTILS TIP: it was not possible to &quot; + &quot;create an empty instance of this Variable &quot;
							+ &quot;type. This is not a problem if you are calling this &quot;
							+ &quot;constructor from a Profile, but if it's from &quot;
							+ &quot;a Request you should use an Object instance &quot; + &quot;with the other constructor.&quot;);
			e.printStackTrace();
			return null;
		}
	}

	/**
	 * This is only supposed to be used internally.
	 *
	 * @return true if constructed for type URI. false if constructed for
	 *         specific value.
	 */
	public boolean byURI() {
		return isByURI;
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/service/Arg.java</td>
<td>universAAL Support Utilities API</td>
<td>45</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/service/Arg.java</td>
<td>universAAL Utilities APIs</td>
<td>45</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class Arg {

	private Arg() {
		// Disallow instantiating
	}

	/**
	 * Equivalent to new Add(byValue);.
	 *
	 * @param byValue
	 *            Value to represent.
	 * @return The argument.
	 */
	public static Add add(Object byValue) {
		return new Add(byValue);
	}

	/**
	 * Equivalent to new Add(byTypeURI);.
	 *
	 * @param byTypeURI
	 *            Type to represent.
	 * @return The argument.
	 */
	public static Add add(String byTypeURI) {
		return new Add(byTypeURI);
	}

	/**
	 * Equivalent to new Change(inputNewValue);.
	 *
	 * @param byValue
	 *            Value to represent.
	 * @return The argument.
	 */
	public static Change change(Object byValue) {
		return new Change(byValue);
	}

	/**
	 * Equivalent to new Change(byTypeURI);.
	 *
	 * @param byTypeURI
	 *            Type to represent.
	 * @return The argument.
	 */
	public static Change change(String byTypeURI) {
		return new Change(byTypeURI);
	}

	/**
	 * Equivalent to new Output(byTypeURIorPLACEHOLDER);.
	 *
	 * @param byTypeURIorPLACEHOLDER
	 *            Type to represent, or placeholder URI.
	 * @return The argument.
	 */
	public static Output out(String byTypeURIorPLACEHOLDER) {
		return new Output(byTypeURIorPLACEHOLDER);
	}

	/**
	 * Equivalent to new Output(byValue);.
	 *
	 * @param byValue
	 *            Value to represent.
	 * @return The argument.
	 */
	public static Output out(Object byValue) {
		return new Output(byValue);
	}

	/**
	 * Equivalent to new Remove(byValue);.
	 *
	 * @param byValue
	 *            Value to represent.
	 * @return The argument.
	 */
	public static Remove remove(Object byValue) {
		return new Remove(byValue);
	}

	/**
	 * Equivalent to new Remove(byTypeURI);.
	 *
	 * @param byTypeURI
	 *            Type to represent.
	 * @return The argument.
	 */
	public static Remove remove(String byTypeURI) {
		return new Remove(byTypeURI);
	}

	/**
	 * Equivalent to new Typematch(byTypeURI);.
	 *
	 * @param byTypeURI
	 *            Type to represent.
	 * @return The argument.
	 */
	public static Typematch type(String byTypeURI) {
		return new Typematch(byTypeURI);
	}

	/**
	 * Equivalent to new Typematch(byValue);.
	 *
	 * @param byValue
	 *            Value to represent.
	 * @return The argument.
	 */
	public static Typematch type(Object byValue) {
		return new Typematch(byValue);
	}

	/**
	 * Equivalent to new Variable(byValue);.
	 *
	 * @param byValue
	 *            Value to represent.
	 * @return The argument.
	 */
	public static Variable in(Object byValue) {
		return new Variable(byValue);
	}

	/**
	 * Equivalent to new Variable(byTypeURI);.
	 *
	 * @param byTypeURI
	 *            Type to represent.
	 * @return The argument.
	 */
	public static Variable in(String byTypeURI) {
		return new Variable(byTypeURI);
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/ui/Control.java</td>
<td>universAAL Support Utilities API</td>
<td>36</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/ui/Control.java</td>
<td>universAAL Utilities APIs</td>
<td>36</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public abstract class Control {

	/**
	 * Default namespace
	 */
	public static final String MY_NAMESPACE = &quot;http://org.universAAL.ontology/SimpleUtils.owl#&quot;;

	/**
	 * Path for ID.
	 */
	protected PropertyPath ref;
	/**
	 * Text label.
	 */
	protected Label label;
	/**
	 * Help text popup.
	 */
	protected String help;
	/**
	 * Hint text popup.
	 */
	protected String hint;

	/**
	 * This method is for internal use of utils only. It creates the actual
	 * official universAAL control configured with the properties defined by this
	 * class. Once it is created it cannot be modified.
	 *
	 * @param group
	 *            The UI group to which the control is being added.
	 * @return An array of Strings representing the property path used to
	 *         identify the control in the response. This is only of interest
	 *         for Input Controls. Submits and Triggers have only one String
	 *         value. If the path has not been set manually by the time this
	 *         method is called, an automatic one must be generated.
	 */
	public abstract String[] create(Group group);

	/**
	 * Get the Help string associated with this control.
	 *
	 * @return The Help String
	 */
	public String getHelp() {
		return help;
	}

	/**
	 * Set the Help string associated with this control.
	 *
	 * @param help
	 *            The Help String
	 */
	public void setHelp(String help) {
		this.help = help;
	}

	/**
	 * Get the Hint string associated with this control.
	 *
	 * @return The Help String
	 */
	public String getHint() {
		return hint;
	}

	/**
	 * Set the Hint string associated with this control.
	 *
	 * @param hint
	 *            The Hint String
	 */
	public void setHint(String hint) {
		this.hint = hint;
	}

	/**
	 * Get the reference Property Path that identifies this control within the
	 * request and the response in the case of Input Controls. For Submits, it
	 * is a single String ID.
	 *
	 * @return The Array of Strings representing the reference Property path
	 */
	public String[] getReference() {
		return ref.getThePath();
	}

	/**
	 * Set the reference Property Path that identifies this control within the
	 * request and the response in the case of Input Controls. For Submits, it
	 * is a single String ID.
	 *
	 * @param reference
	 *            The String representing the reference Property path or ID
	 */
	public void setReference(String reference) {
		if (reference != null) {
			ref = new PropertyPath(null, false, new String[] { reference });
		} else {
			ref = null;
		}
	}

	/**
	 * Set the reference Property Path that identifies this control within the
	 * request and the response in the case of Input Controls. For Submits, it
	 * is a single String ID, so it only counts the last value.
	 *
	 * @param reference
	 *            The Array of Strings representing the reference Property path
	 *            or ID
	 */
	public void setReference(String[] reference) {
		if (reference != null) {
			ref = new PropertyPath(null, false, reference);
		} else {
			ref = null;
		}
	}

	/**
	 * Get the Label string associated with this control.
	 *
	 * @return The Label String
	 */
	public String getLabel() {
		return label.getText();
	}

	/**
	 * Set the Label string associated with this control.
	 *
	 * @param txt
	 *            The Label String
	 */
	public void setLabel(String txt) {
		label = new Label(txt, null);
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/ui/TriggerCmd.java</td>
<td>universAAL Support Utilities API</td>
<td>49</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/ui/TriggerCmd.java</td>
<td>universAAL Utilities APIs</td>
<td>49</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class TriggerCmd extends SubmitCmd {

	/**
	 * Generic empty constructor. The TriggerCmd will be generated with default
	 * values (empty).
	 */
	public TriggerCmd() {
	}

	/**
	 * Constructor with the reference of the trigger to be used in request and
	 * response. The reference is a single ID String. All other properties of
	 * the input are set to defaults (empty).
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 */
	public TriggerCmd(String ref) {
		super(ref);
	}

	/**
	 * Constructor with the reference of the trigger to be used in request and
	 * response. The reference is a single ID String.
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 * @param label
	 *            The label text that identifies the trigger to the user.
	 */
	public TriggerCmd(String ref, String label) {
		super(ref, label);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see org.universAAL.support.utils.ui.SubmitCmd#create(org.universAAL.
	 * middleware.ui.rdf.Group)
	 */
	public String[] create(Group group) {
		if (ref == null) {
			setReference(MY_NAMESPACE + StringUtils.createUniqueID());
		}
		SubdialogTrigger sub = new SubdialogTrigger(group, label, ref.getLastPathElement());
		if (confirmMessage != null) {
			switch (confirmType) {
			case Submit.CONFIRMATION_TYPE_OK_CANCEL:
				sub.setConfirmationOkCancel(confirmMessage);
				break;
			case Submit.CONFIRMATION_TYPE_YES_NO:
				sub.setConfirmationYesNo(confirmMessage);
				break;
			default:
				sub.setConfirmationOkCancel(confirmMessage);
				break;
			}
		}
		if (!l.isEmpty()) {
			Iterator iter = l.iterator();
			while (iter.hasNext()) {
				sub.addMandatoryInput((Input) iter.next());
			}
		}
		if (sub.needsSelection()) {
			sub.setRepeatableIDPrefix(ref.getLastPathElement());
		}
		return ref.getThePath();
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/ui/Check.java</td>
<td>universAAL Support Utilities API</td>
<td>46</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/ui/Check.java</td>
<td>universAAL Utilities APIs</td>
<td>46</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class Check extends InputControl {

	/**
	 * Initial value.
	 */
	private Boolean initialValue = Boolean.FALSE;

	/**
	 * Generic empty constructor. The Input will be generated with default
	 * values (false).
	 */
	public Check() {
	}

	/**
	 * Constructor with the reference of the input to be used in request and
	 * response. The reference is a property path, but in this constructor it is
	 * simplified as a single String (a single-property path). All other
	 * properties of the input are set to defaults (false). Use method
	 * setReference(String[] path) to set a path through several properties.
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 */
	public Check(String ref) {
		setReference(ref);
	}

	/**
	 * Constructor with the reference of the input to be used in request and
	 * response. The reference is a property path, but in this constructor it is
	 * simplified as a single String (a single-property path). Use method
	 * setReference(String[] path) to set a path through several properties.
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 * @param label
	 *            The label text that identifies the input to the user.
	 */
	public Check(String ref, String label) {
		setReference(ref);
		this.label = new Label(label, null);
	}

	/**
	 * Constructor with the reference of the input to be used in request and
	 * response. The reference is a property path, but in this constructor it is
	 * simplified as a single String (a single-property path). Use method
	 * setReference(String[] path) to set a path through several properties.
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 * @param label
	 *            The label text that identifies the input to the user.
	 * @param initialValue
	 *            The value the boolean input field has by default. If it is not
	 *            changed by the user this will be the value of the input in the
	 *            response.
	 */
	public Check(String ref, String label, Boolean initialValue) {
		setReference(ref);
		this.label = new Label(label, null);
		this.initialValue = initialValue;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.universAAL.support.utils.ui.Control#create(org.universAAL.middleware.
	 * ui.rdf.Group)
	 */
	public String[] create(Group group) {
		if (ref == null) {
			setReference(MY_NAMESPACE + StringUtils.createUniqueID());
		}
		model = new InputField(group, label, ref, MergedRestriction.getAllValuesRestrictionWithCardinality(
				ref.getLastPathElement(), TypeMapper.getDatatypeURI(Boolean.class), 1, 1), initialValue);
		return ref.getThePath();
	}

	/**
	 * Get the initial value of the input by default.
	 *
	 * @return The initial value.
	 */
	public Boolean getInitialValue() {
		return initialValue;
	}

	/**
	 * Set the initial value of the input by default.
	 *
	 * @param initialValue
	 *            The initial value.
	 */
	public void setInitialValue(Boolean initialValue) {
		this.initialValue = initialValue;
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/service/Path.java</td>
<td>universAAL Support Utilities API</td>
<td>45</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/service/Path.java</td>
<td>universAAL Utilities APIs</td>
<td>45</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class Path {
	/**
	 * Holds the value of the path.
	 */
	public String[] path;

	/**
	 * Main constructor. It can be used to type
	 * &lt;code&gt;new Path(firstproperty)...&lt;/code&gt; instead of
	 * &lt;code&gt;Path.at(firstproperty)...&lt;/code&gt;
	 *
	 * @param path
	 *            The first property of the path, coming from the service root
	 */
	public Path(String path) {
		this.path = new String[] { path };
	}

	/**
	 * Additional constructor if you already have a property path but want to
	 * turn it into a Path object. You can add more steps to the path
	 * afterwards.
	 *
	 * @param path
	 *            The property path, coming from the service root
	 */
	public Path(String[] path) {
		this.path = path;
	}

	/**
	 * Deprecated. Use at() instead. You save 2 letters.
	 *
	 * @param to
	 *            The first property of the path, coming from the service root
	 * @return New Path instance
	 */
	@Deprecated
	public static Path start(String to) {
		return new Path(to);
	}

	/**
	 * Return a new instance of Path starting its branch path at parameter to.
	 *
	 * @param to
	 *            The first property of the path, coming from the service root
	 * @return New Path instance
	 */
	public static Path at(String to) {
		return new Path(to);
	}

	/**
	 * Puts a new step (a new property) in the branch path. Allows successive
	 * calls to add further properties.
	 *
	 * @param to
	 *            The next property in the path, coming from a previous call to
	 *            .start
	 * @return Itself
	 */
	public Path to(String to) {
		String[] obj = new String[this.path.length + 1];
		for (int i = 0; i &lt; this.path.length; i++) {
			obj[i] = this.path[i];
		}
		obj[obj.length - 1] = to;
		this.path = obj;
		return this;
	}

	/**
	 * Get a Path object with the given property path.
	 *
	 * @param path
	 *            The property path
	 * @return The Path object representing it
	 */
	public static Path parse(String[] path) {
		return new Path(path);
	}

	/**
	 * Get a Path object with the given property path.
	 *
	 * @param path
	 *            The single step property path
	 * @return The Path object representing it
	 */
	public static Path parse(String path) {
		return new Path(path);
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/service/top/UtilSensorCallee.java</td>
<td>universAAL Support Utilities API</td>
<td>46</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/service/top/UtilSensorCallee.java</td>
<td>universAAL Utilities APIs</td>
<td>46</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public abstract class UtilSensorCallee extends ServiceCallee {

	/**
	 * Namespace for auxiliary URIs used in this class.
	 */
	private String calleeNamespace;

	/**
	 * Default error response.
	 */
	private ServiceResponse errorResponse = new ServiceResponse(CallStatus.serviceSpecificFailure);

	/**
	 * Default constructor of the class. Takes the same parameters needed by a
	 * UtilSensor profile method, in addition to the ModuleContext.
	 * &lt;p&gt;
	 * BE CAREFUL: This will only work with sensors that have StatusValue as
	 * HAS_VALUE property. Others, like DimmerSensor, will throw an exception.
	 *
	 * @param context
	 *            The Module Context of universAAL
	 * @param namespace
	 *            The namespace of your server, ending with the character #
	 * @param sensor
	 *            The ontology instance of the sensor you are controlling. The
	 *            more properties it has set, the better.
	 * @throws InvalidOntologyUtilException
	 *             when an sensor is passed that is does not have StatusValue as
	 *             type restriction of its HAS_VALUE property.
	 */
	public UtilSensorCallee(ModuleContext context, String namespace, Sensor sensor)
			throws InvalidOntologyUtilException {
		super(context, UtilSensor.getServiceProfiles(namespace, sensor));
		this.calleeNamespace = namespace;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.universAAL.middleware.service.ServiceCallee#handleCall(org.universAAL
	 * .middleware.service.ServiceCall)
	 */
	@Override
	public ServiceResponse handleCall(ServiceCall call) {
		if (call == null) {
			return null;
		}
		String operation = call.getProcessURI();
		if (operation == null) {
			return null;
		}
		if (operation.startsWith(calleeNamespace + UtilSensor.SERVICE_GET_ON_OFF)) {
			boolean result = executeGet();
			ServiceResponse response = new ServiceResponse(CallStatus.succeeded);
			response.addOutput(new ProcessOutput(calleeNamespace + UtilSensor.OUT_GET_ON_OFF,
					result ? StatusValue.Activated : StatusValue.NotActivated));
			return response;
		}

		errorResponse.addOutput(new ProcessOutput(ServiceResponse.PROP_SERVICE_SPECIFIC_ERROR,
				&quot;The service requested has not been implemented in this simple editor callee&quot;));
		return errorResponse;
	}

	/**
	 * When a GET STATUS service request is received, this method is called
	 * automatically.
	 *
	 * @return The Boolean value representing the measured value property of the
	 *         sensor.
	 */
	public abstract boolean executeGet();

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/ui/Media.java</td>
<td>universAAL Support Utilities API</td>
<td>47</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/ui/Media.java</td>
<td>universAAL Utilities APIs</td>
<td>47</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class Media extends Control {

	/**
	 * Type of media.
	 */
	private String type = &quot;IMG&quot;;
	/**
	 * URL to media in resource server.
	 */
	private String url;

	/**
	 * Generic empty constructor. The Output will be generated with default
	 * values (empty).
	 */
	public Media() {
	}

	/**
	 * Constructor with only the url. All other properties of the input are set
	 * to defaults (empty image).
	 *
	 * @param url
	 *            The URL to the value to be displayed, from the Resource
	 *            server.
	 */
	public Media(String url) {
		this.url = url;
	}

	/**
	 * Constructor with the URL value.
	 *
	 * @param label
	 *            The label text that identifies the output to the user.
	 * @param url
	 *            The URL to the value to be displayed, from the Resource
	 *            server.
	 */
	public Media(String label, String url) {
		this.label = new Label(label, null);
		this.url = url;
	}

	/**
	 * Constructor with the URL value.
	 *
	 * @param label
	 *            The label text that identifies the output to the user.
	 * @param url
	 *            The URL to the value to be displayed, from the Resource
	 *            server.
	 * @param type
	 *            The type of media element. By default it's IMG.
	 */
	public Media(String label, String url, String type) {
		this.label = new Label(label, null);
		this.url = url;
		this.type = type;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.universAAL.support.utils.ui.Control#create(org.universAAL.middleware.
	 * ui.rdf.Group)
	 */
	public String[] create(Group group) {
		new MediaObject(group, label, type, url);
		return new String[] {};
	}

	/**
	 * Get the URL to the the value to be displayed, from the Resource server.
	 *
	 * @return The URL
	 */
	public String getUrl() {
		return url;
	}

	/**
	 * Set the URL to the the value to be displayed, from the Resource server.
	 *
	 * @param url
	 *            The URL
	 */
	public void setUrl(String url) {
		this.url = url;
	}

	/**
	 * Get the type of media element of the value.
	 *
	 * @return The media type
	 */
	public String getType() {
		return type;
	}

	/**
	 * Set the type of media element of the value.
	 *
	 * @param type
	 *            The media type
	 */
	public void setType(String type) {
		this.type = type;
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/context/mid/UtilPublisher.java</td>
<td>universAAL Support Utilities API</td>
<td>51</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/context/mid/UtilPublisher.java</td>
<td>universAAL Utilities APIs</td>
<td>51</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class UtilPublisher extends DefaultContextPublisher {

	/**
	 * Create a simple &lt;b&gt;gauge&lt;/b&gt; Context Publisher which provided events can
	 * be of any type and is identified with the given URI.
	 *
	 * @param context
	 *            The universAAL module context.
	 * @param uri
	 *            The URI that identifies the Context Provider.
	 */
	public UtilPublisher(ModuleContext context, String uri) {
		super(context, new Provider(uri));
	}

	/**
	 * Create a simple Context Publisher of the given type which provided events
	 * can be of any type and is identified with the given URI.
	 *
	 * @param context
	 *            The universAAL module context.
	 * @param uri
	 *            The URI that identifies the Context Provider.
	 * @param type
	 *            The type of Context Provider, one of Gauge, Controller or
	 *            Reasoner.
	 */
	public UtilPublisher(ModuleContext context, String uri, ContextProviderType type) {
		super(context, new Provider(uri, type));
	}

	/**
	 * Create a simple Context Publisher of the given type which provided events
	 * are described by a pattern and is identified with the given URI.
	 *
	 * @param context
	 *            The universAAL module context.
	 * @param uri
	 *            The URI that identifies the Context Provider.
	 * @param type
	 *            The type of Context Provider, one of Gauge, Controller or
	 *            Reasoner.
	 * @param pattern
	 *            Array of Patterns describing the provided events, as normally
	 *            used in the native API.
	 */
	public UtilPublisher(ModuleContext context, String uri, ContextProviderType type, ContextEventPattern[] pattern) {
		super(context, new Provider(uri, type, pattern));
	}

	/**
	 * Create a simple Context Publisher of the given type which provided events
	 * are described by the arguments and is identified with the given URI.
	 *
	 * @param context
	 *            The universAAL module context.
	 * @param uri
	 *            The URI that identifies the Context Provider.
	 * @param type
	 *            The type of Context Provider, one of Gauge, Controller or
	 *            Reasoner.
	 * @param subjTypeURI
	 *            The type URI that the provided events subject must have. Null
	 *            for any.
	 * @param predicate
	 *            The exact predicate that the provided events must equal. Null
	 *            for any.
	 * @param objTypeURI
	 *            The type URI that the provided events object must have. Null
	 *            for any.
	 */
	public UtilPublisher(ModuleContext context, String uri, ContextProviderType type, String subjTypeURI,
			String predicate, String objTypeURI) {
		super(context, new Provider(uri, type, subjTypeURI, predicate, objTypeURI));
	}

	/**
	 * Create a simple Context Publisher of the given type which provided events
	 * are described by the arguments and is identified with the given URI.
	 *
	 * @param context
	 *            The universAAL module context.
	 * @param uri
	 *            The URI that identifies the Context Provider.
	 * @param type
	 *            The type of Context Provider, one of Gauge, Controller or
	 *            Reasoner.
	 * @param sub
	 *            The exact instance that the provided events subject must
	 *            equal. Null for any.
	 * @param predicate
	 *            The exact predicate that the provided events must equal. Null
	 *            for any.
	 * @param objTypeURI
	 *            The type URI that the provided events object must have. Null
	 *            for any.
	 */
	public UtilPublisher(ModuleContext context, String uri, ContextProviderType type, ManagedIndividual sub,
			String predicate, String objTypeURI) {
		super(context, new Provider(uri, type, sub, predicate, objTypeURI));
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/ui/Grouping.java</td>
<td>universAAL Support Utilities API</td>
<td>50</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/ui/Grouping.java</td>
<td>universAAL Utilities APIs</td>
<td>50</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class Grouping extends Control implements IContainer {

	/**
	 * Resource backing up data in group.
	 */
	private Resource root = null;
	/**
	 * Holds the group model.
	 */
	private Group model;

	/**
	 * Generic empty constructor. The Group will be generated with default
	 * values (empty).
	 */
	public Grouping() {
	}

	/**
	 * Constructor with the reference of the Group to be used in response. The
	 * reference is a property path, but in this constructor it is simplified as
	 * a single String (a single-property path). All other properties of the
	 * input are set to defaults (empty). Use method setReference(String[] path)
	 * to set a path through several properties.
	 *
	 * @param ref
	 *            The simple reference identifying the group. Set to null to
	 *            auto-generate.
	 */
	public Grouping(String ref) {
		setReference(ref);
	}

	/**
	 * Constructor with the reference of the group to be used in response. The
	 * reference is a property path, but in this constructor it is simplified as
	 * a single String (a single-property path). Use method
	 * setReference(String[] path) to set a path through several properties.
	 *
	 * @param ref
	 *            The simple reference identifying the group. Set to null to
	 *            auto-generate.
	 * @param label
	 *            The label text that identifies the group to the user.
	 */
	public Grouping(String ref, String label) {
		setReference(ref);
		this.label = new Label(label, null);
	}

	/**
	 * Constructor with the reference of the group to be used in response. The
	 * reference is a property path, but in this constructor it is simplified as
	 * a single String (a single-property path). Use method
	 * setReference(String[] path) to set a path through several properties.
	 *
	 * @param ref
	 *            The simple reference identifying the group. Set to null to
	 *            auto-generate.
	 * @param label
	 *            The label text that identifies the group to the user.
	 * @param root
	 *            The root Resource for the child elements to be added to this
	 *            group.
	 */
	public Grouping(String ref, String label, Resource root) {
		setReference(ref);
		this.label = new Label(label, null);
		this.root = root;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.universAAL.support.utils.ui.Control#create(org.universAAL.middleware.
	 * ui.rdf.Group)
	 */
	public String[] create(Group group) {
		if (ref == null) {
			setReference(MY_NAMESPACE + StringUtils.createUniqueID());
		}
		model = new Group(group, label, ref, null, root);
		return ref.getThePath();
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.universAAL.support.utils.ui.IContainer#add(org.universAAL.samples.ui.
	 * utils.SimpleControl)
	 */
	public String[] add(Control ctrl) {
		return ctrl.create(model);
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/ui/Text.java</td>
<td>universAAL Support Utilities API</td>
<td>44</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/ui/Text.java</td>
<td>universAAL Utilities APIs</td>
<td>44</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class Text extends InputControl {

	/**
	 * Initial value.
	 */
	protected String initialValue;

	/**
	 * Generic empty constructor. The Input will be generated with default
	 * values (empty).
	 */
	public Text() {
	}

	/**
	 * Constructor with the reference of the input to be used in request and
	 * response. The reference is a property path, but in this constructor it is
	 * simplified as a single String (a single-property path). All other
	 * properties of the input are set to defaults (empty). Use method
	 * setReference(String[] path) to set a path through several properties.
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 */
	public Text(String ref) {
		setReference(ref);
	}

	/**
	 * Constructor with the reference of the input to be used in request and
	 * response. The reference is a property path, but in this constructor it is
	 * simplified as a single String (a single-property path). Use method
	 * setReference(String[] path) to set a path through several properties.
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 * @param label
	 *            The label text that identifies the input to the user.
	 */
	public Text(String ref, String label) {
		setReference(ref);
		this.label = new Label(label, null);
	}

	/**
	 * Constructor with the reference of the input to be used in request and
	 * response. The reference is a property path, but in this constructor it is
	 * simplified as a single String (a single-property path). Use method
	 * setReference(String[] path) to set a path through several properties.
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 * @param label
	 *            The label text that identifies the input to the user.
	 * @param initialValue
	 *            The value the text input field has by default. If it is not
	 *            changed by the user this will be the value of the input in the
	 *            response.
	 */
	public Text(String ref, String label, String initialValue) {
		setReference(ref);
		this.label = new Label(label, null);
		this.initialValue = initialValue;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.universAAL.support.utils.ui.Control#create(org.universAAL.middleware.
	 * ui.rdf.Group)
	 */
	public String[] create(Group group) {
		if (ref == null) {
			setReference(MY_NAMESPACE + StringUtils.createUniqueID());
		}
		model = new InputField(group, label, ref, null, initialValue);
		return ref.getThePath();
	}

	/**
	 * Get the initial value of the input by default.
	 *
	 * @return The initial value.
	 */
	public String getInitialValue() {
		return initialValue;
	}

	/**
	 * Set the initial value of the input by default.
	 *
	 * @param initialValue
	 *            The initial value.
	 */
	public void setInitialValue(String initialValue) {
		this.initialValue = initialValue;
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/ui/Out.java</td>
<td>universAAL Support Utilities API</td>
<td>44</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/ui/Out.java</td>
<td>universAAL Utilities APIs</td>
<td>44</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class Out extends Control {

	/**
	 * Output value.
	 */
	private String value;

	/**
	 * Generic empty constructor. The Output will be generated with default
	 * values (empty).
	 */
	public Out() {
	}

	/**
	 * Constructor with the output value. All other properties of the input are
	 * set to defaults (empty).
	 *
	 * @param value
	 *            The output value to be displayed.
	 */
	public Out(String value) {
		this.value = value;
	}

	/**
	 * Constructor with the output value.
	 *
	 * @param label
	 *            The label text that identifies the output to the user.
	 * @param value
	 *            The output value to be displayed.
	 */
	public Out(String label, String value) {
		this.label = new Label(label, null);
		this.value = value;
	}

	/**
	 * Constructor with the reference of the output to be used in request. The
	 * reference is a property path, but in this constructor it is simplified as
	 * a single String (a single-property path). For outputs, references are
	 * only used in conjunction with initial root Resources. Use method
	 * setReference(String[] path) to set a path through several properties.
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 * @param label
	 *            The label text that identifies the output to the user.
	 * @param value
	 *            The output value to be displayed.
	 */
	public Out(String ref, String label, String value) {
		setReference(ref);
		this.label = new Label(label, null);
		this.value = value;
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.universAAL.support.utils.ui.Control#create(org.universAAL.middleware.
	 * ui.rdf.Group)
	 */
	public String[] create(Group group) {
		if (ref == null) {
			setReference(MY_NAMESPACE + StringUtils.createUniqueID());
		}
		new SimpleOutput(group, label, ref, value);
		return ref.getThePath();
	}

	/**
	 * Get the output value to be displayed.
	 *
	 * @return The output value
	 */
	public String getValue() {
		return value;
	}

	/**
	 * Set the output value to be displayed.
	 *
	 * @param value
	 *            The output value
	 */
	public void setValue(String value) {
		this.value = value;
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/context/mid/UtilSubscriber.java</td>
<td>universAAL Support Utilities API</td>
<td>48</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/context/mid/UtilSubscriber.java</td>
<td>universAAL Utilities APIs</td>
<td>48</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public abstract class UtilSubscriber extends ContextSubscriber {

	/**
	 * Create a simple Context Subscriber that will listen to the events
	 * matching what is specified in the constructor.
	 *
	 * @param context
	 *            The universAAL module context.
	 * @param subjTypeURI
	 *            The type URI that the provided events subject must have. Null
	 *            for any.
	 * @param predicate
	 *            The exact predicate that the provided events must equal. Null
	 *            for any.
	 * @param objTypeURI
	 *            The type URI that the provided events object must have. Null
	 *            for any.
	 */
	protected UtilSubscriber(ModuleContext context, String subjTypeURI, String predicate, String objTypeURI) {
		super(context, new ContextEventPattern[] { new Pattern(subjTypeURI, predicate, objTypeURI) });
	}

	/**
	 * Create a simple Context Subscriber that will listen to the events
	 * matching what is specified in the constructor.
	 *
	 * @param context
	 *            The universAAL module context.
	 * @param subj
	 *            The exact instance that the provided events subject must
	 *            equal. Null for any.
	 * @param predicate
	 *            The exact predicate that the provided events must equal. Null
	 *            for any.
	 * @param objTypeURI
	 *            The type URI that the provided events object must have. Null
	 *            for any.
	 */
	protected UtilSubscriber(ModuleContext context, ManagedIndividual subj, String predicate, String objTypeURI) {
		super(context, new ContextEventPattern[] { new Pattern(subj, predicate, objTypeURI) });
	}

	/**
	 * Create a simple Context Subscriber that will listen to the events
	 * matching what is specified in the constructor.
	 *
	 * @param context
	 *            The universAAL module context.
	 * @param subj
	 *            The exact instance that the event subject must equal. Null for
	 *            any.
	 * @param predicate
	 *            The exact predicate that the event must equal. Null for any.
	 * @param obj
	 *            The exact instance that the event object must equal. Null for
	 *            any.
	 */
	protected UtilSubscriber(ModuleContext context, ManagedIndividual subj, String predicate, Object obj) {
		super(context, new ContextEventPattern[] { new Pattern(subj, predicate, obj) });
	}

	/**
	 * Create a simple Context Subscriber that will listen to the events
	 * matching what is specified in the constructor.
	 *
	 * @param context
	 *            The universAAL module context.
	 * @param subjTypeURI
	 *            The type URI that the event subject must have. Null for any.
	 * @param predicate
	 *            The exact predicate that the event must equal. Null for any.
	 * @param obj
	 *            The exact instance that the event object must equal. Null for
	 *            any.
	 */
	protected UtilSubscriber(ModuleContext context, String subjTypeURI, String predicate, Object obj) {
		super(context, new ContextEventPattern[] { new Pattern(subjTypeURI, predicate, obj) });
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/ui/low/Dialog.java</td>
<td>universAAL Support Utilities API</td>
<td>178</td></tr>
<tr class="a">
<td>org/universAAL/support/utils/ui/low/SubDialog.java</td>
<td>universAAL Support Utilities API</td>
<td>139</td></tr>
<tr class="b">
<td>org/universAAL/utilities/api/ui/low/Dialog.java</td>
<td>universAAL Utilities APIs</td>
<td>178</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/ui/low/SubDialog.java</td>
<td>universAAL Utilities APIs</td>
<td>139</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>		props.put(PROP_DIALOG_FORM, Form.newDialog(title, root));
		props.put(PROP_DIALOG_PRIORITY, priority);
		props.put(PROP_DIALOG_LANGUAGE, Locale.getDefault());
		props.put(PROP_DIALOG_PRIVACY_LEVEL, privacy);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.universAAL.support.utils.ui.IContainer#add(org.universAAL.samples.ui.
	 * utils.SimpleControl)
	 */
	public String[] add(Control ctrl) {
		return ctrl.create(getDialogForm().getIOControls());
	}

	/**
	 * Add a Submit Form Control to the Submit group of the Dialog. Submit group
	 * is for Submits that end the dialog or lead to new dialogs.
	 *
	 * @param ctrl
	 *            The Submit to add
	 * @return The String representing the ID to be used to identify the Submit
	 *         in the response.
	 */
	public String addSubmit(SubmitCmd ctrl) {
		String[] ref = ctrl.create(getDialogForm().getSubmits());
		return ref[ref.length - 1];
	}

	/**
	 * Add a hidden object so it is sent within the UI request, but not shown to
	 * the user. When the UI response is being handled by the UI caller, this
	 * hidden input can be retrieved by calling
	 * &lt;code&gt;uiresponse.getUserInput(new String[]{ref});&lt;/code&gt; , being
	 * &lt;code&gt;ref&lt;/code&gt; the one you used in this method.
	 *
	 * @param ref
	 *            The reference you will use to access the hidden object later
	 *            from the response
	 * @param hidden
	 *            The object you want to hide
	 */
	public void addHidden(String ref, Object hidden) {
		this.getDialogForm().getData().setPropertyPath(new String[] { ref }, hidden);
	}

	/**
	 * Add an extra property to the form used in this UI request. Extra
	 * properties may be used by I/O Handlers to allow the developer to
	 * fine-tune things like the layout. The equivalent in native API is to call
	 * setProperty() on a Form object. Use this only as recommended by the
	 * Handler you intend to use, since it is the Handler the one who will
	 * interpret the property.
	 *
	 * @param property
	 *            The property of a Form that a certain Handler will inspect for
	 *            its own purposes.
	 * @param extra
	 *            The value to be set into the property.
	 */
	public void addExtra(String property, Object extra) {
		this.getDialogForm().setProperty(property, extra);
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/service/Add.java</td>
<td>universAAL Support Utilities API</td>
<td>38</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/service/Add.java</td>
<td>universAAL Utilities APIs</td>
<td>38</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class Add extends Value {

	/**
	 * Holds the value of the argument.
	 */
	private Object value;

	/**
	 * &lt;b&gt;Recommended for use by SimpleRequests&lt;/b&gt;. Value used to define values
	 * to add as arguments of a Request. If this constructor is used by Simple
	 * Profiles with a specific instance value the input is not treated as a
	 * variable reference but as a explicit added value.
	 *
	 * @param byValue
	 *            An instance of a ManagedIndividual or native type representing
	 *            the value to add
	 */
	public Add(Object byValue) {
		this.isByURI = false;
		this.value = byValue;
		this.uri = ManagedIndividual.getTypeURI(byValue);
	}

	/**
	 * &lt;b&gt;Recommended for use by SimpleProfiles&lt;/b&gt;. Value used to define values
	 * to add as arguments of a Profile.
	 *
	 * @param byTypeURI
	 *            A type URI of a ManagedIndividual or native type representing
	 *            the type of value to add. However if the parameter is not a
	 *            valid URI, it will be understood as an instance of a String,
	 *            as if it used the &quot;byValue&quot; constructor instead.
	 */
	public Add(String byTypeURI) {
		this.isByURI = true;
		this.uri = byTypeURI;
		this.value = Resource.getResource(byTypeURI, Resource.generateAnonURI());
		if (this.value == null) {
			if (TypeMapper.isRegisteredDatatypeURI(byTypeURI)) {
				this.value = createEmptyInstance(byTypeURI);
			} else {
				// An arbitrary String, not an URI, intended use is like byValue
				this.isByURI = false;
				this.uri = TypeMapper.getDatatypeURI(String.class);
				this.value = byTypeURI;
			}
		}
	}

	/**
	 * This is only supposed to be used internally.
	 *
	 * @return The actual value of the value to add
	 */
	public Object getObject() {
		return value;
	}

	/**
	 * This is only supposed to be used internally.
	 *
	 * @return The type URI of the value to add
	 */
	public String getURI() {
		return uri;
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/service/Change.java</td>
<td>universAAL Support Utilities API</td>
<td>38</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/service/Change.java</td>
<td>universAAL Utilities APIs</td>
<td>38</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class Change extends Value {
	/**
	 * Holds the value of the argument.
	 */
	private Object value;

	/**
	 * &lt;b&gt;Recommended for use by SimpleRequests&lt;/b&gt;. Value used to define values
	 * to change as arguments of a Request. If this constructor is used by
	 * Simple Profiles with a specific instance value the input is not treated
	 * as a variable reference but as a explicit added value.
	 *
	 * @param byValue
	 *            An instance of a ManagedIndividual or native type representing
	 *            the new value to set
	 */
	public Change(Object byValue) {
		this.isByURI = false;
		this.value = byValue;
		this.uri = ManagedIndividual.getTypeURI(byValue);
	}

	/**
	 * &lt;b&gt;Recommended for use by SimpleProfiles&lt;/b&gt;. Value used to define values
	 * to change as arguments of a Profile.
	 *
	 * @param byTypeURI
	 *            A type URI of a ManagedIndividual or native type representing
	 *            the type of new value to set. However if the parameter is not
	 *            a valid URI, it will be understood as an instance of a String,
	 *            as if it used the &quot;byValue&quot; constructor instead.
	 */
	public Change(String byTypeURI) {
		this.isByURI = true;
		this.uri = byTypeURI;
		this.value = Resource.getResource(byTypeURI, Resource.generateAnonURI());
		if (this.value == null) {
			if (TypeMapper.isRegisteredDatatypeURI(byTypeURI)) {
				this.value = createEmptyInstance(byTypeURI);
			} else {
				// An arbitrary String, not an URI, intended use is like byValue
				this.isByURI = false;
				this.uri = TypeMapper.getDatatypeURI(String.class);
				this.value = byTypeURI;
			}
		}
	}

	/**
	 * This is only supposed to be used internally.
	 *
	 * @return The actual value of the value to change
	 */
	public Object getObject() {
		return value;
	}

	/**
	 * This is only supposed to be used internally.
	 *
	 * @return The type URI of the value to change
	 */
	public String getURI() {
		return uri;
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/service/Remove.java</td>
<td>universAAL Support Utilities API</td>
<td>38</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/service/Remove.java</td>
<td>universAAL Utilities APIs</td>
<td>38</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class Remove extends Value {
	/**
	 * Holds the value of the argument.
	 */
	private Object value;

	/**
	 * &lt;b&gt;Recommended for use by SimpleRequests&lt;/b&gt;. Value used to define values
	 * to remove as arguments of a Request. If this constructor is used by
	 * Simple Profiles with a specific instance value the input is not treated
	 * as a variable reference but as a explicit added value.
	 *
	 * @param byValue
	 *            An instance of a ManagedIndividual or native type representing
	 *            the value to be removed
	 */
	public Remove(Object byValue) {
		this.isByURI = false;
		this.value = byValue;
		this.uri = ManagedIndividual.getTypeURI(byValue);
	}

	/**
	 * &lt;b&gt;Recommended for use by SimpleProfiles&lt;/b&gt;. Value used to define values
	 * to remove as arguments of a Profile.
	 *
	 * @param byTypeURI
	 *            A type URI of a ManagedIndividual or native type representing
	 *            the type of value to be removed. However if the parameter is
	 *            not a valid URI, it will be understood as an instance of a
	 *            String, as if it used the &quot;byValue&quot; constructor instead.
	 */
	public Remove(String byTypeURI) {
		this.isByURI = true;
		this.uri = byTypeURI;
		this.value = Resource.getResource(byTypeURI, Resource.generateAnonURI());
		if (this.value == null) {
			if (TypeMapper.isRegisteredDatatypeURI(byTypeURI)) {
				this.value = createEmptyInstance(byTypeURI);
			} else {
				// An arbitrary String, not an URI, intended use is like byValue
				this.isByURI = false;
				this.uri = TypeMapper.getDatatypeURI(String.class);
				this.value = byTypeURI;
			}
		}
	}

	/**
	 * This is only supposed to be used internally.
	 *
	 * @return The actual value of the value to remove
	 */
	public Object getObject() {
		return value;
	}

	/**
	 * This is only supposed to be used internally.
	 *
	 * @return The type URI of the value to remove
	 */
	public String getURI() {
		return uri;
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/service/Variable.java</td>
<td>universAAL Support Utilities API</td>
<td>39</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/service/Variable.java</td>
<td>universAAL Utilities APIs</td>
<td>39</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class Variable extends Value {
	/**
	 * Holds the value of the argument.
	 */
	private Object value;

	/**
	 * &lt;b&gt;Recommended for use by SimpleRequests&lt;/b&gt;. Value used to define values
	 * to be used as variable inputs in arguments of a Request or Profile. If
	 * this constructor is used by Simple Profiles with a specific instance
	 * value the input is not treated as a variable reference but as a explicit
	 * required input.
	 *
	 * @param byValue
	 *            An instance of a ManagedIndividual or native type representing
	 *            the value that must be passed as variable input to the service
	 */
	public Variable(Object byValue) {
		this.isByURI = false;
		this.value = byValue;
		this.uri = ManagedIndividual.getTypeURI(byValue);
	}

	/**
	 * &lt;b&gt;Recommended for use by SimpleProfiles&lt;/b&gt;. Value used to define values
	 * to be used as variable inputs in arguments of a Profile.
	 *
	 * @param byTypeURI
	 *            A type URI of a ManagedIndividual or native type representing
	 *            the type of value that must be passed as variable input to the
	 *            service. However if the parameter is not a valid URI, it will
	 *            be understood as an instance of a String, as if it used the
	 *            &quot;byValue&quot; constructor instead.
	 */
	public Variable(String byTypeURI) {
		this.isByURI = true;
		this.uri = byTypeURI;
		this.value = Resource.getResource(byTypeURI, Resource.generateAnonURI());

		if (this.value == null) {
			if (TypeMapper.isRegisteredDatatypeURI(byTypeURI)) {
				this.value = createEmptyInstance(byTypeURI);
			} else {
				// An arbitrary String, not an URI, intended use is like byValue
				this.isByURI = false;
				this.uri = TypeMapper.getDatatypeURI(String.class);
				this.value = byTypeURI;
			}
		}
	}

	/**
	 * This is only supposed to be used internally.
	 *
	 * @return The actual value of the variable
	 */
	public Object getObject() {
		return value;
	}

	/**
	 * This is only supposed to be used internally.
	 *
	 * @return The type URI of the variable
	 */
	public String getURI() {
		return uri;
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/ui/SelectOne.java</td>
<td>universAAL Support Utilities API</td>
<td>53</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/ui/SelectOne.java</td>
<td>universAAL Utilities APIs</td>
<td>53</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class SelectOne extends SelectMulti {

	/**
	 * Generic empty constructor. The Input will be generated with default
	 * values (first).
	 */
	public SelectOne() {
	}

	/**
	 * Constructor with the reference of the input to be used in request and
	 * response. The reference is a property path, but in this constructor it is
	 * simplified as a single String (a single-property path). All other
	 * properties of the input are set to defaults (first). Use method
	 * setReference(String[] path) to set a path through several properties.
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 */
	public SelectOne(String ref) {
		super(ref);
	}

	/**
	 * Constructor with the reference of the input to be used in request and
	 * response. The reference is a property path, but in this constructor it is
	 * simplified as a single String (a single-property path). Use method
	 * setReference(String[] path) to set a path through several properties.
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 * @param label
	 *            The label text that identifies the input to the user.
	 */
	public SelectOne(String ref, String label) {
		super(ref, label);
	}

	/**
	 * Constructor with the reference of the input to be used in request and
	 * response. The reference is a property path, but in this constructor it is
	 * simplified as a single String (a single-property path). All other
	 * properties of the input are set to defaults (first). Use method
	 * setReference(String[] path) to set a path through several properties.
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 * @param label
	 *            The label text that identifies the input to the user.
	 * @param initialOptions
	 *            An array of Objects that represent the different possible
	 *            options to select.
	 */
	public SelectOne(String ref, String label, Object[] initialOptions) {
		super(ref, label, initialOptions);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see org.universAAL.support.utils.ui.SelectMulti#create(org.universAAL.
	 * middleware.ui.rdf.Group)
	 */
	public String[] create(Group group) {
		if (ref == null) {
			setReference(MY_NAMESPACE + StringUtils.createUniqueID());
		}
		// if(initialValue==null)initialValue=Integer.valueOf(0);
		model = new Select1(group, label, ref, null,
				initialValue != null ? getOptions()[initialValue.intValue()] : null);
		((Select1) model).generateChoices(getOptions());
		// TODO: use storeUserInput for the initial value, because it seems
		// generatechoices overrides it
		return ref.getThePath();
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/ui/low/Dialog.java</td>
<td>universAAL Support Utilities API</td>
<td>178</td></tr>
<tr class="a">
<td>org/universAAL/support/utils/ui/low/Message.java</td>
<td>universAAL Support Utilities API</td>
<td>125</td></tr>
<tr class="b">
<td>org/universAAL/support/utils/ui/low/SubDialog.java</td>
<td>universAAL Support Utilities API</td>
<td>139</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/ui/low/Dialog.java</td>
<td>universAAL Utilities APIs</td>
<td>178</td></tr>
<tr class="b">
<td>org/universAAL/utilities/api/ui/low/Message.java</td>
<td>universAAL Utilities APIs</td>
<td>125</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/ui/low/SubDialog.java</td>
<td>universAAL Utilities APIs</td>
<td>139</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>		props.put(PROP_DIALOG_FORM, Form.newDialog(title, root));
		props.put(PROP_DIALOG_PRIORITY, priority);
		props.put(PROP_DIALOG_LANGUAGE, Locale.getDefault());
		props.put(PROP_DIALOG_PRIVACY_LEVEL, privacy);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.universAAL.support.utils.ui.IContainer#add(org.universAAL.samples.ui.
	 * utils.SimpleControl)
	 */
	public String[] add(Control ctrl) {
		return ctrl.create(getDialogForm().getIOControls());
	}

	/**
	 * Add a Submit Form Control to the Submit group of the Dialog. Submit group
	 * is for Submits that end the dialog or lead to new dialogs.
	 *
	 * @param ctrl
	 *            The Submit to add
	 * @return The String representing the ID to be used to identify the Submit
	 *         in the response.
	 */
	public String addSubmit(SubmitCmd ctrl) {
		String[] ref = ctrl.create(getDialogForm().getSubmits());
		return ref[ref.length - 1];
	}

	/**
	 * Add a hidden object so it is sent within the UI request, but not shown to
	 * the user. When the UI response is being handled by the UI caller, this
	 * hidden input can be retrieved by calling
	 * &lt;code&gt;uiresponse.getUserInput(new String[]{ref});&lt;/code&gt; , being
	 * &lt;code&gt;ref&lt;/code&gt; the one you used in this method.
	 *
	 * @param ref
	 *            The reference you will use to access the hidden object later
	 *            from the response
	 * @param hidden
	 *            The object you want to hide
	 */
	public void addHidden(String ref, Object hidden) {
		this.getDialogForm().getData().setPropertyPath(new String[] { ref }, hidden);
	}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/ui/Area.java</td>
<td>universAAL Support Utilities API</td>
<td>45</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/ui/Area.java</td>
<td>universAAL Utilities APIs</td>
<td>45</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>public class Area extends Text {

	/**
	 * Generic empty constructor. The Input will be generated with default
	 * values (empty).
	 */
	public Area() {
	}

	/**
	 * Constructor with the reference of the input to be used in request and
	 * response. The reference is a property path, but in this constructor it is
	 * simplified as a single String (a single-property path). All other
	 * properties of the input are set to defaults (empty). Use method
	 * setReference(String[] path) to set a path through several properties.
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 */
	public Area(String ref) {
		super(ref);
	}

	/**
	 * Constructor with the reference of the input to be used in request and
	 * response. The reference is a property path, but in this constructor it is
	 * simplified as a single String (a single-property path). Use method
	 * setReference(String[] path) to set a path through several properties.
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 * @param label
	 *            The label text that identifies the input to the user.
	 */
	public Area(String ref, String label) {
		super(ref, label);
	}

	/**
	 * Constructor with the reference of the input to be used in request and
	 * response. The reference is a property path, but in this constructor it is
	 * simplified as a single String (a single-property path). Use method
	 * setReference(String[] path) to set a path through several properties.
	 *
	 * @param ref
	 *            The simple reference identifying the input. Set to null to
	 *            auto-generate.
	 * @param label
	 *            The label text that identifies the input to the user.
	 * @param initialValue
	 *            The value the text input field has by default. If it is not
	 *            changed by the user this will be the value of the input in the
	 *            response.
	 */
	public Area(String ref, String label, String initialValue) {
		super(ref, label, initialValue);
	}

	/*
	 * (non-Javadoc)
	 *
	 * @see
	 * org.universAAL.support.utils.ui.Text#create(org.universAAL.middleware.ui.
	 * rdf.Group)
	 */
	public String[] create(Group group) {
		if (ref == null) {
			setReference(MY_NAMESPACE + StringUtils.createUniqueID());
		}
		model = new TextArea(group, label, ref, null, initialValue);
		return ref.getThePath();
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/context/Pattern.java</td>
<td>universAAL Support Utilities API</td>
<td>154</td></tr>
<tr class="a">
<td>org/universAAL/support/utils/context/Pattern.java</td>
<td>universAAL Support Utilities API</td>
<td>196</td></tr>
<tr class="b">
<td>org/universAAL/utilities/api/context/Pattern.java</td>
<td>universAAL Utilities APIs</td>
<td>154</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/context/Pattern.java</td>
<td>universAAL Utilities APIs</td>
<td>196</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>	public Pattern(ManagedIndividual subj, String predicate, String objTypeURI) {
		super();
		if (subj != null) {
			String uri = ManagedIndividual.getTypeURI(subj);
			if (uri != null &amp;&amp; Resource.isQualifiedName(uri)) {
				this.addRestriction(MergedRestriction.getFixedValueRestriction(ContextEvent.PROP_RDF_SUBJECT, subj));
			} else {
				System.out.println(MSG_INST);
			}
		}
		if (predicate != null) {
			if (Resource.isQualifiedName(predicate)) {
				this.addRestriction(
						MergedRestriction.getFixedValueRestriction(ContextEvent.PROP_RDF_PREDICATE, predicate));
			} else {
				System.out.println(MSG_PRED);
			}
		}
		if (objTypeURI != null) {</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/context/Pattern.java</td>
<td>universAAL Support Utilities API</td>
<td>120</td></tr>
<tr class="a">
<td>org/universAAL/support/utils/context/Pattern.java</td>
<td>universAAL Support Utilities API</td>
<td>203</td></tr>
<tr class="b">
<td>org/universAAL/utilities/api/context/Pattern.java</td>
<td>universAAL Utilities APIs</td>
<td>120</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/context/Pattern.java</td>
<td>universAAL Utilities APIs</td>
<td>203</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>				System.out.println(MSG_STR);
			}
		}
		if (predicate != null) {
			if (Resource.isQualifiedName(predicate)) {
				this.addRestriction(
						MergedRestriction.getFixedValueRestriction(ContextEvent.PROP_RDF_PREDICATE, predicate));
			} else {
				System.out.println(MSG_PRED);
			}
		}
		if (obj != null) {
			String uri = ManagedIndividual.getTypeURI(obj);
			if (uri != null &amp;&amp; Resource.isQualifiedName(uri)) {
				this.addRestriction(MergedRestriction.getFixedValueRestriction(ContextEvent.PROP_RDF_OBJECT, obj));
			} else {
				System.out.println(MSG_INST);
			}
		}
	}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/service/Add.java</td>
<td>universAAL Support Utilities API</td>
<td>71</td></tr>
<tr class="a">
<td>org/universAAL/support/utils/service/Change.java</td>
<td>universAAL Support Utilities API</td>
<td>70</td></tr>
<tr class="b">
<td>org/universAAL/support/utils/service/Remove.java</td>
<td>universAAL Support Utilities API</td>
<td>70</td></tr>
<tr class="a">
<td>org/universAAL/support/utils/service/Variable.java</td>
<td>universAAL Support Utilities API</td>
<td>73</td></tr>
<tr class="b">
<td>org/universAAL/utilities/api/service/Add.java</td>
<td>universAAL Utilities APIs</td>
<td>71</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/service/Change.java</td>
<td>universAAL Utilities APIs</td>
<td>70</td></tr>
<tr class="b">
<td>org/universAAL/utilities/api/service/Remove.java</td>
<td>universAAL Utilities APIs</td>
<td>70</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/service/Variable.java</td>
<td>universAAL Utilities APIs</td>
<td>73</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>	public Add(String byTypeURI) {
		this.isByURI = true;
		this.uri = byTypeURI;
		this.value = Resource.getResource(byTypeURI, Resource.generateAnonURI());
		if (this.value == null) {
			if (TypeMapper.isRegisteredDatatypeURI(byTypeURI)) {
				this.value = createEmptyInstance(byTypeURI);
			} else {
				// An arbitrary String, not an URI, intended use is like byValue
				this.isByURI = false;
				this.uri = TypeMapper.getDatatypeURI(String.class);
				this.value = byTypeURI;
			}
		}
	}

	/**
	 * This is only supposed to be used internally.
	 *
	 * @return The actual value of the value to add
	 */
	public Object getObject() {
		return value;
	}

	/**
	 * This is only supposed to be used internally.
	 *
	 * @return The type URI of the value to add
	 */
	public String getURI() {
		return uri;
	}

}</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/service/mid/UtilActuator.java</td>
<td>universAAL Support Utilities API</td>
<td>129</td></tr>
<tr class="a">
<td>org/universAAL/support/utils/service/mid/UtilSensor.java</td>
<td>universAAL Support Utilities API</td>
<td>117</td></tr>
<tr class="b">
<td>org/universAAL/utilities/api/service/mid/UtilActuator.java</td>
<td>universAAL Utilities APIs</td>
<td>129</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/service/mid/UtilSensor.java</td>
<td>universAAL Utilities APIs</td>
<td>117</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>		MergedRestriction r = MergedRestriction.getFixedValueRestriction(DeviceService.PROP_CONTROLS, actuator);

		Service getOnOff = (Service) OntologyManagement.getInstance().getResource(ontologyURI,
				namespace + SERVICE_GET_ON_OFF);
		profiles[0] = getOnOff.getProfile();
		ProcessOutput output = new ProcessOutput(namespace + OUT_GET_ON_OFF);
		output.setCardinality(1, 1);
		profiles[0].addOutput(output);
		profiles[0].addSimpleOutputBinding(output, ppath.getThePath());
		profiles[0].addInput(input);
		profiles[0].getTheService().addInstanceLevelRestriction(r, new String[] { DeviceService.PROP_CONTROLS });</pre></div></td></tr></table>
<table border="0" class="bodyTable">
<tr class="a">
<th>File</th>
<th>Project</th>
<th>Line</th></tr>
<tr class="b">
<td>org/universAAL/support/utils/ui/SubmitCmd.java</td>
<td>universAAL Support Utilities API</td>
<td>119</td></tr>
<tr class="a">
<td>org/universAAL/support/utils/ui/TriggerCmd.java</td>
<td>universAAL Support Utilities API</td>
<td>95</td></tr>
<tr class="b">
<td>org/universAAL/utilities/api/ui/SubmitCmd.java</td>
<td>universAAL Utilities APIs</td>
<td>119</td></tr>
<tr class="a">
<td>org/universAAL/utilities/api/ui/TriggerCmd.java</td>
<td>universAAL Utilities APIs</td>
<td>95</td></tr>
<tr class="b"><td colspan='3'>
<div>
<pre>		Submit sub = new Submit(group, label, ref.getLastPathElement());
		if (confirmMessage != null) {
			switch (confirmType) {
			case Submit.CONFIRMATION_TYPE_OK_CANCEL:
				sub.setConfirmationOkCancel(confirmMessage);
				break;
			case Submit.CONFIRMATION_TYPE_YES_NO:
				sub.setConfirmationYesNo(confirmMessage);
				break;
			default:
				sub.setConfirmationOkCancel(confirmMessage);
				break;
			}
		}
		if (!l.isEmpty()) {
			Iterator iter = l.iterator();
			while (iter.hasNext()) {
				sub.addMandatoryInput((Input) iter.next());
			}
		}
		if (h != null) {</pre></div></td></tr></table></div>
      </div>
    </div>
    <div class="clear">
      <hr/>
    </div>
    <div id="footer">
      <div class="xright">
              Copyright &#169;                    ${currentYear}
                        <a href="http://www.universAAL.org/">universAAL Consortium</a>.
            All rights reserved.    
                  </div>
      <div class="clear">
        <hr/>
      </div>
    </div>
  </body>
</html>
